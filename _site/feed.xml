<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-27T04:43:15+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">parklego dev log</title><subtitle>Build Jekyll site with the GitBook style.
</subtitle><author><name>parklego</name></author><entry><title type="html">생각정리</title><link href="http://localhost:4000/til/think.html" rel="alternate" type="text/html" title="생각정리" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/think</id><content type="html" xml:base="http://localhost:4000/til/think.html"><![CDATA[<h2 id="라이트다크-모드">라이트/다크 모드</h2>

<p>최근에 create-react-app을 더 이상 사용하지 않는다는 소식을 들었다. 그래서 다음에는 vite를 이용해보고자 했는데 드디어 사용해보게 되었다.</p>

<p>새로 해보는 만큼 라이브러리도 써보지 않은 다양한 것을 사용해보고 싶었다. 그래서 shadcn도 설정하였다.</p>

<p>설정하는 단계가 조금 귀찮다. 그리고 문서가 자세하지가 않다. 그렇지만 이쁘다.</p>

<p>그리고 상태관리로는 최근에 가장 가파른 상승세를 타고 있는 zustand를 사용해보기로 했다.</p>

<p>처음에 해보고 싶었던 것은 라이트/다크모드를 설정해보는 기능을 구현해보고 싶었다.</p>

<p>localstorage를 이용해서 구현할 것이고, styled-component의 <code class="language-plaintext highlighter-rouge">themeProvider</code>로 구현하고자 하였다.</p>

<p>그런데 zustand에 localstorage가 있었다. 그래서 persist middleware와 함께 이용하기로 했다.</p>

<p>shadcn의 switch 컴포넌트를 이용해 토글기능으로 다크모드를 on/off 하였다. 그러다 ux측면도 고려해보게 되었다.</p>

<p>내가 주로 검색하는데 사용하는 phind와 shadcn의 다크모드 기능을 살펴보았다.</p>

<ul>
  <li>phind의 경우에는 처음에 os의 테마를 바탕으로 사이트를 변경해준다. 이때 localstorage에는 테마의 키-벨류가 없다. 그리고 유저가 테마를 건드리면 그때 키-벨류값이 생기고 이에따라 테마가 변경된다.</li>
  <li>shadcn의 경우 처음부터 라이트/다크/시스템 이렇게 선택할 수 있게 설정이 되어 있다.</li>
</ul>

<p>다크모드 구현이 단순한 기능인줄 알았는데 생각보다 다양한 방법도 있다는 것을 알았다. UX도 생각보다 빠르게 발전하고 있구나 싶었다.</p>

<p>os 테마변경에 따른 실시간 변경을 위해 커스텀훅을 만들어서 구현하였다.</p>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[라이트/다크 모드]]></summary></entry><entry><title type="html">Git/Github</title><link href="http://localhost:4000/til/git-github.html" rel="alternate" type="text/html" title="Git/Github" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/git%20github</id><content type="html" xml:base="http://localhost:4000/til/git-github.html"><![CDATA[<h2 id="jekyll을-사용하여-github-pages-배포-및-테마적용">Jekyll을 사용하여 GitHub Pages 배포 및 테마적용</h2>

<blockquote>
  <p>사전 준비</p>
</blockquote>

<ul>
  <li>Ruby 설치</li>
  <li>Jekyll 설치</li>
  <li>테마 선택
    <ul>
      <li><a href="http://jamstackthemes.dev">jamstackthemes.dev</a></li>
      <li><a href="http://jekyllthemes.org/">http://jekyllthemes.org/</a></li>
    </ul>
  </li>
  <li>코드블럭 선택
    <ul>
      <li><a href="https://spsarolkar.github.io/rouge-theme-preview/">https://spsarolkar.github.io/rouge-theme-preview/</a>
<br /></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>배포 및 테마 적용하기</p>
</blockquote>

<ol>
  <li>
    <p>github repository 생성</p>

    <ul>
      <li>repository명은 github 아이디.github.io로 생성할 것</li>
      <li>repository는 public 으로 할 것</li>
      <li>ex) parklego.github.io</li>
    </ul>
  </li>
  <li>
    <p>bundle 명령어 실행</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle install
bundle exec jekyll serve
</code></pre></div>    </div>
  </li>
  <li>
    <p>블로그 설정</p>
    <ul>
      <li>_conif.yml 파일에서 제목이나 이름 등을 변경</li>
      <li>Gemfile 플러그인 설치하는 곳</li>
    </ul>
  </li>
</ol>

<h2 id="siteamp-파일-생성">siteamp 파일 생성</h2>

<ol>
  <li>
    <p>Gemfile 파일에서 아래 코드 추가</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem 'jekyll-sitemap'
</code></pre></div>    </div>
  </li>
  <li>
    <p>_config.yml 파일에서 아래 코드 추가</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins:
   -jekyll - sitemap;
</code></pre></div>    </div>
  </li>
  <li>Terminal 에서 <code class="language-plaintext highlighter-rouge">bundle</code> 입력.</li>
  <li>
    <p>Terminal 에서 아래 명령어 입력</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem install jekyll-sitemap
</code></pre></div>    </div>
  </li>
  <li>
    <p>지킬 서버 재실행</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle exec jekyll serve
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[Jekyll을 사용하여 GitHub Pages 배포 및 테마적용]]></summary></entry><entry><title type="html">JWT 적용기</title><link href="http://localhost:4000/til/jwt.html" rel="alternate" type="text/html" title="JWT 적용기" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/jwt</id><content type="html" xml:base="http://localhost:4000/til/jwt.html"><![CDATA[<blockquote>
  <p>사전 준비</p>
</blockquote>

<ol>
  <li>cookie parser</li>
  <li>cors
    <ul>
      <li>origin 설정</li>
      <li>credentials true</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<blockquote>
  <p>JWT 로직</p>
</blockquote>

<ul>
  <li>
    <p>로그인 시 인증 서버로부터 access token, refresh token을 쿠키에 넣어서 보내준다.</p>

    <p>(중요) refresh token은 httpOnly / secure / SameSite 옵션을 준다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">maxAge</span><span class="p">:</span> <span class="mi">300000</span><span class="p">,</span> <span class="c1">// 5m</span>
  <span class="nx">httpOnly</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">secure</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">sameSite</span><span class="p">:</span> <span class="dl">"</span><span class="s2">strict</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>인증 체계를 다음과 같이 만든다.</p>

    <ol>
      <li>
        <p>쿠키에 엑세스토큰이 있는지 확인한다.</p>

        <ul>
          <li>엑세스 토큰이 없다면 엑세스토큰을 재발급 절차를 받는다. (2번으로 이동)</li>
          <li>엑세스 토큰 있다면 엑세스토큰을 확인 절차를 밟는다. (종료)</li>
        </ul>
      </li>
      <li>
        <p>재발급을 받는 절차에서 리프레시 토큰을 확인한다.</p>
        <ul>
          <li>리프레시 토큰이 없거나 유효하지 않으면 로그인 페이지로 이동시킨다. (종료)</li>
          <li>리프레시 토큰이 유효하다면 새로운 엑세스토큰을 발급해준다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><br />
<br /></p>

<p>token의 저장 위치에 관하여는 언제나 말이 많았다. 예전에 나는 localstorage에 저장해서 이번에는 cookie에 한 번 담아 본 것이다.</p>

<p>리액트같은 경우에 access token을 private 변수로 저장해놓고 사용해도 된다고 한다. 왜냐하면 어차피 refresh token이 있으니까 재발급받으면 된다는 의미인 것 같았다.</p>

<p>refresh token을 일회성으로 사용하는 RTR (Refresh Token Rotation)이라는 방법도 있다.</p>

<p>그러고 보니 access token을 헤더에 실어 보낼 때 어떻게 했더라 싶어서 다시 찾아봤다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">accessToken</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">accessToken</span><span class="dl">"</span><span class="p">)</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">requestData</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nx">axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="dl">"</span><span class="s2">http://localhost:8000/like</span><span class="dl">"</span><span class="p">,</span> <span class="nx">requestData</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">Authorization</span><span class="p">:</span> <span class="s2">`Bearer </span><span class="p">${</span><span class="nx">accessToken</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">});</span>
</code></pre></div></div>

<p>아. 그리고 Bearer를 항상 붙였었는데 이건 일종의 약속이라서 그렇다고 한다.</p>

<p><code class="language-plaintext highlighter-rouge">Authorization: &lt;type&gt; &lt;credentials&gt;</code></p>

<p>Bearer 타입은 JWT 혹은 OAuth에 대한 토큰을 사용한다는 뜻.</p>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[사전 준비]]></summary></entry><entry><title type="html">MongoDB</title><link href="http://localhost:4000/til/mongoDB.html" rel="alternate" type="text/html" title="MongoDB" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/mongoDB</id><content type="html" xml:base="http://localhost:4000/til/mongoDB.html"><![CDATA[<h2 id="overwritemodelerror">OverwriteModelError</h2>

<blockquote>
  <p>런타임 에러</p>
</blockquote>

<p>⨯ OverwriteModelError: Cannot overwrite <code class="language-plaintext highlighter-rouge">Users</code> model once compiled.</p>

<p><br /></p>

<blockquote>
  <p>해결책</p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="kd">const</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">mongoose</span><span class="p">.</span><span class="nx">models</span><span class="p">.</span><span class="nx">Users</span> <span class="o">||</span> <span class="nx">mongoose</span><span class="p">.</span><span class="nx">model</span><span class="p">(</span><span class="dl">"</span><span class="s2">Users</span><span class="dl">"</span><span class="p">,</span> <span class="nx">userSchema</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">User</span><span class="p">;</span>
</code></pre></div></div>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[OverwriteModelError]]></summary></entry><entry><title type="html">네트워크</title><link href="http://localhost:4000/til/network.html" rel="alternate" type="text/html" title="네트워크" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/network</id><content type="html" xml:base="http://localhost:4000/til/network.html"><![CDATA[<h2 id="rest-api란-무엇인가">REST API란 무엇인가?</h2>

<p>REST API란 REST를 기반으로 만들어진 API를 의미한다. REST API를 알기 위해 REST부터 알아야 한다.</p>

<h3 id="rest">REST</h3>

<p>REST(Representational State Transfer)의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미.</p>

<p>HTTP URI를 통해 자원을 명시하고, HTTP Method (POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD OPERATION을 적용하는 것을 의미한다.</p>

<p><br /></p>

<blockquote>
  <p>참고 : PUT vs PATCH</p>
</blockquote>

<ul>
  <li>PUT : 리소스의 모든 것을 업데이트 한다. 덮어씌운다는 느낌. 보내지 않은 데이터는 null로 반환.</li>
  <li>PATCH : 리소스의 일부를 업데이트 한다. 일부를 수정하는 느낌. 보낸 데이터만 수정됨.</li>
</ul>

<blockquote>
  <p>참고 : Get은 왜 body에 데이터를 넣으면 안될까?</p>
</blockquote>

<ul>
  <li>GET 요청은 서버에서 리소스를 검색하기 위해 설계되었다.</li>
  <li>HTTP 명세서에서 GET 요청에서 메시지 바디를 사용하지 않는 것은 캐시 및 보안 문제를 일으킬 수 있기 때문이다.</li>
</ul>

<h3 id="rest-api">REST API</h3>

<p>REST의 원리를 따르는 API.</p>

<ol>
  <li>URL은 동사보다는 명사, 대문자보다는 소문자를 사용한다.</li>
  <li>슬래시(/)는 계층 관계를 나타내는데 사용한다.</li>
  <li>마지막은 슬래시(/)를 포함하지 않는다.</li>
  <li>언더바(_)대신 하이픈(-)을 사용한다.</li>
  <li>파일확장자는 URL에 포함하지 않는다.</li>
</ol>

<p>또한, REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함되어야 한다.</p>

<p><br /></p>

<blockquote>
  <p>자주 사용되는 상태코드</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">상태코드</th>
      <th style="text-align: center">상태</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">200</td>
      <td style="text-align: center">OK</td>
      <td>서버가 요청을 성공적으로 처리하였다.</td>
    </tr>
    <tr>
      <td style="text-align: center">201</td>
      <td style="text-align: center">Created</td>
      <td>요청이 처리되어서 새로운 리소스가 생성되었다.</td>
    </tr>
    <tr>
      <td style="text-align: center">202</td>
      <td style="text-align: center">Accepted</td>
      <td>요청은 접수하였지만, 처리가 완료되지 않았다.</td>
    </tr>
    <tr>
      <td style="text-align: center">400</td>
      <td style="text-align: center">Bad Request</td>
      <td>서버가 요청을 성공적으로 처리하였다.</td>
    </tr>
    <tr>
      <td style="text-align: center">401</td>
      <td style="text-align: center">Unauthorized</td>
      <td>지정한 리소스에 대한 액세스 권한이 없다.</td>
    </tr>
    <tr>
      <td style="text-align: center">403</td>
      <td style="text-align: center">Forbidden</td>
      <td>지정한 리소스에 대한 액세스가 금지되었다.</td>
    </tr>
    <tr>
      <td style="text-align: center">404</td>
      <td style="text-align: center">Not Found</td>
      <td>지정한 리소스를 찾을 수 없다.</td>
    </tr>
    <tr>
      <td style="text-align: center">500</td>
      <td style="text-align: center">Internal Server Error</td>
      <td>서버에 에러가 발생하였다.</td>
    </tr>
    <tr>
      <td style="text-align: center">501</td>
      <td style="text-align: center">Not Implemented</td>
      <td>요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다.</td>
    </tr>
    <tr>
      <td style="text-align: center">502</td>
      <td style="text-align: center">Bad Gateway</td>
      <td>웹서버가 다른 서버로부터의 잘못된 응답을 받았을 때 발생한다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<blockquote>
  <p>참고 : 4xx vs 5xx</p>
</blockquote>

<ul>
  <li>4xx : 클라이언트 에러</li>
  <li>5xx : 서버 에러</li>
</ul>

<h3 id="restful">RESTful</h3>

<p>REST API의 모든 설계 규칙을 올바르게 지킨 시스템을 <code class="language-plaintext highlighter-rouge">RESTful하다</code> 라고 한다.</p>

<hr />

<p><a href="https://khj93.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-REST-API%EB%9E%80-REST-RESTful%EC%9D%B4%EB%9E%80">REST API란</a></p>

<p><a href="https://velog.io/@somday/RESTful-API-%EC%9D%B4%EB%9E%80">RESTful API란</a></p>

<p><a href="https://meetup.nhncloud.com/posts/92">REST API 제대로 알고 사용하기</a></p>

<p><a href="https://hongong.hanbit.co.kr/http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C-%ED%91%9C-1xx-5xx-%EC%A0%84%EC%B2%B4-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/">http 상태코드</a></p>

<p><a href="https://youtu.be/7LbylTMlj8M?si=3sIqGqs1GyTF_aLE">제대로 이해하는 REST API</a></p>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[REST API란 무엇인가?]]></summary></entry><entry><title type="html">Next.js</title><link href="http://localhost:4000/til/next.html" rel="alternate" type="text/html" title="Next.js" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/next</id><content type="html" xml:base="http://localhost:4000/til/next.html"><![CDATA[<h2 id="nextjs를-사용해야-하는-이유">Next.js를 사용해야 하는 이유</h2>

<ol>
  <li>폴더를 사용하여 페이지를 간단하게 만들 수 있다.
    <ul>
      <li>리액트의 경우, <code class="language-plaintext highlighter-rouge">react-router-dom</code>을 사용하여 하나하나 만들어줘야 함</li>
    </ul>
  </li>
  <li>자체 api를 생성할 수 있다.</li>
  <li>SSR과 CSR을 함께 사용 할 수 있다.</li>
  <li>최적화가 잘 되어 있다.
    <ul>
      <li>코드 분할, 이미지 최적화 등 추가적인 작업을 안해도 되서 편하다.</li>
    </ul>
  </li>
  <li>리액트 팀에서도 next.js 프레임워크를 사용하기를 권장한다.</li>
</ol>

<p><br /></p>

<blockquote>
  <p>런타임 에러</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(node:29569) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead.
(Use `node --trace-deprecation ...` to show where the warning was created)
</code></pre></div></div>

<p><br /></p>

<blockquote>
  <p>해결책</p>
</blockquote>

<p>nvm을 사용하여, node 18버전으로 다운그레이드</p>

<h2 id="라우팅">라우팅</h2>

<ol>
  <li>app폴더 하위 폴더에 라우팅하고 싶은 페이지명을 폴더명으로 만든다.</li>
  <li>그 폴더에는 page.js로 파일을 만든다.
    <ul>
      <li>동적라우팅의 경우 [id] 와 같이 대괄호 안에 넣어준다.</li>
      <li>그룹화 하고 싶은 경우 (auth) 와 같이 소괄호 안에 넣어준다. 이때 라우팅에서 그룹화 부분은 무시된다.</li>
    </ul>
  </li>
</ol>

<h2 id="이미지">이미지</h2>

<p>이미지 가져오는 방법은 3가지가 있다.</p>

<ol>
  <li>폴더안에 파일의 경로를 넣는 경우
    <ul>
      <li>너비와 높이를 지정해야한다.</li>
    </ul>
  </li>
  <li>폴더안에 파일을 import 해서 넣는 경우
    <ul>
      <li>너비와 높이를 지정하지 않아도 된다.</li>
    </ul>
  </li>
  <li>외부 경로를 넣는 경우
    <ul>
      <li>너비와 높이를 지정해야한다.</li>
      <li>next.js에서는 기본적으로 외부 이미지를 허용하지 않는다.</li>
      <li>사용하려면 해당 이미지의 도메인을 적어주어야 한다.</li>
    </ul>
  </li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// next.config.js</span>

<span class="kd">const</span> <span class="nx">nextConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">images</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">domains</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">example.com</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">nextConfig</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="api">API</h2>

<ol>
  <li>app폴더 하위 폴더에 api 폴더를 만들고, 라우팅하고 싶은 api를 폴더명으로 만든다.</li>
  <li>그 폴더에는 route.js로 파일을 만든다.
    <ul>
      <li>동적라우팅의 경우 [id] 와 같이 대괄호 안에 넣어준다.</li>
    </ul>
  </li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">NextResponse</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/server</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">GET</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">id</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">params</span><span class="p">;</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">connect</span><span class="p">();</span>

    <span class="kd">const</span> <span class="nx">post</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">Post</span><span class="p">.</span><span class="nx">findById</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nx">NextResponse</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">post</span><span class="p">),</span> <span class="p">{</span>
      <span class="na">status</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
    <span class="p">});</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">NextResponse</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">status</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<blockquote>
  <p>params 가져오기</p>
</blockquote>

<p>Next.js의 API 라우트에서는 요청 객체가 res 매개변수를 통해 전달된다. 따라서 API 라우트에서는 res.params를 사용하여 경로 매개변수를 가져와야 한다.</p>

<h2 id="metadata">Metadata</h2>

<p>각 페이지에 해당 객체를 입력만 해도 간단하게 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">metadata</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">title</span><span class="p">:</span> <span class="dl">"</span><span class="s2">parklego</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">description</span><span class="p">:</span> <span class="dl">"</span><span class="s2">parklego next tutorial</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>동적 페이지 경우에는 아래와 같이 생성하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">generateMetadata</span> <span class="o">=</span> <span class="k">async</span> <span class="p">({</span> <span class="nx">params</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">post</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">getData</span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">title</span><span class="p">:</span> <span class="nx">post</span><span class="p">.</span><span class="nx">title</span><span class="p">,</span> <span class="c1">// params someting..</span>
    <span class="na">description</span><span class="p">:</span> <span class="nx">post</span><span class="p">.</span><span class="nx">desc</span><span class="p">,</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="next-auth-authjs">Next-auth (Auth.js)</h2>

<p><a href="https://authjs.dev/getting-started/providers/oauth-tutorial">OAuth authentication</a></p>

<ol>
  <li>
    <p>핸들러 함수를 정의</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/api/auth/[...nextauth].js</span>

<span class="kd">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="nx">NextAuth</span><span class="p">({</span>
  <span class="na">providers</span><span class="p">:</span> <span class="p">[</span>
    <span class="nx">GoogleProvider</span><span class="p">({</span>
      <span class="na">clientId</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">GOOGLE_CLIENT_ID</span><span class="p">,</span>
      <span class="na">clientSecret</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">GOOGLE_CLIENT_SECRET</span><span class="p">,</span>
    <span class="p">}),</span>
  <span class="p">],</span>
<span class="p">});</span>

<span class="k">export</span> <span class="p">{</span> <span class="nx">handler</span> <span class="k">as</span> <span class="nx">GET</span><span class="p">,</span> <span class="nx">handler</span> <span class="k">as</span> <span class="nx">POST</span> <span class="p">};</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>.env 파일에서 변수를 추가한다.</p>

    <pre><code class="language-env">...
NEXTAUTH_SECRET = 'next-tutorial'
NEXTAUTH_URL='https:localhost:3000'
...

</code></pre>
  </li>
  <li>
    <p>layout.js 에서 provider로 감싸준다.
(provider는 서버 컴포넌트에서 사용못하므로 따로 빼주어야 한다.)</p>

    <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">use client</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">SessionProvider</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next-auth/react</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">AuthProvider</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">children</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nc">SessionProvider</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">children</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">SessionProvider</span><span class="p">&gt;;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">AuthProvider</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>로그인</p>

    <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">signIn</span><span class="p">,</span> <span class="nx">useSession</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next-auth/react</span><span class="dl">"</span><span class="p">;</span>

<span class="p">...</span>

<span class="kd">const</span> <span class="nx">session</span> <span class="o">=</span> <span class="nx">useSession</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="nx">useRouter</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">session</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">loading</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">return</span> <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>loading..<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span> <span class="c1">// spinner</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">session</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">authenticated</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">"</span><span class="s2">/dashboard</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>
<span class="k">return</span> <span class="p">(</span>
 <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">signIn</span><span class="p">(</span><span class="dl">"</span><span class="s2">google</span><span class="dl">"</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>login with google<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">)</span>

</code></pre></div>    </div>
  </li>
  <li>
    <p>로그아웃</p>

    <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">signOut</span><span class="p">,</span> <span class="nx">useSession</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next-auth/react</span><span class="dl">"</span><span class="p">;</span>

<span class="p">...</span>

<span class="p">{</span>
 <span class="nx">session</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">authenticated</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="p">(</span>
     <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">signOut</span><span class="si">}</span><span class="p">&gt;</span>logout<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
 <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>protected 페이지</p>

    <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="p">...</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">session</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">loading</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>loading..<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">session</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">unauthenticated</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">"</span><span class="s2">/dashboard/login</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">session</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">authenticated</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// someting ..</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="스트리밍">스트리밍</h2>

<ol>
  <li>전체 스트리밍
    <ul>
      <li>loading.jsx 파일을 만들면 된다. 이 로딩은 같은 폴더 내 다른 페이지에도 영향을 끼친다.</li>
      <li>그래서 로딩 스켈레톤을 만들려면 라우트를 그룹화 하여 만들면 된다.</li>
    </ul>
  </li>
  <li>
    <p>구성요소 스트리밍</p>

    <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Suspense</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

 <span class="p">...</span>
 <span class="k">return</span> <span class="p">(</span>
     <span class="p">&lt;&gt;</span>
       <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
         <span class="p">&lt;</span><span class="nc">Suspense</span> <span class="na">fallback</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nc">CardsSkeleton</span> <span class="p">/&gt;</span><span class="si">}</span><span class="p">&gt;</span>
           <span class="p">&lt;</span><span class="nc">CardWrapper</span> <span class="p">/&gt;</span>
         <span class="p">&lt;/</span><span class="nc">Suspense</span><span class="p">&gt;</span>
       <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
       <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
         <span class="p">&lt;</span><span class="nc">Suspense</span> <span class="na">fallback</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nc">RevenueChartSkeleton</span> <span class="p">/&gt;</span><span class="si">}</span><span class="p">&gt;</span>
           <span class="p">&lt;</span><span class="nc">RevenueChart</span> <span class="p">/&gt;</span>
         <span class="p">&lt;/</span><span class="nc">Suspense</span><span class="p">&gt;</span>
       <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
     <span class="p">&lt;/&gt;</span>
 <span class="p">)</span>

</code></pre></div>    </div>
  </li>
</ol>

<h2 id="error">Error</h2>

<ol>
  <li>error.jsx는 모든 오류를 처리하는 페이지이다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">use client</code> 사용</li>
    </ul>
  </li>
  <li>
    <p>not-found.jsx 페이지가 error.jsx 페이지보다 우선 순위가 높다.</p>

    <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">notFound</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">next/navigation</span><span class="dl">'</span><span class="p">;</span>

<span class="p">...</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">invoice</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">notFound</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">...</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="접근성-향상">접근성 향상</h2>

<p>기본적으로 <code class="language-plaintext highlighter-rouge">eslint-plugin-jsx-a11y</code>라는 플러그인이 포함되어 있다.
이미지태그에서 alt가 빠진 경우나, aria-* 및 role 속성을 잘못 사용하는 경우 등을 경고해준다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">scripts</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="dl">"</span><span class="s2">lint</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">next lint</span><span class="dl">"</span>
<span class="p">},</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm run lint
</code></pre></div></div>

<h2 id="deploy">Deploy</h2>

<p>Vercel로 간단하게 프로젝트를 배포할 수 있다. 놀라웠던 점은 Git 저장소를 연결하고 특정 브랜치에 변경 사항이 푸시되면 자동으로 배포를 하더라.
그리고 무중단 배포를 하기때문에 걱정도 덜하다.</p>

<p><a href="https://vercel.com/">vercel.com</a></p>

<hr />

<p><a href="https://nextjs.org/learn?utm_source=next-site&amp;utm_medium=homepage-cta&amp;utm_campaign=home">next.js learn</a>
<a href="https://youtu.be/VE8BkImUciY?si=0PfRB52RXLW6H9PS">next.js tutorial</a></p>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[Next.js를 사용해야 하는 이유]]></summary></entry><entry><title type="html">웹 접근성</title><link href="http://localhost:4000/til/web-Accessibility.html" rel="alternate" type="text/html" title="웹 접근성" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/web%20Accessibility</id><content type="html" xml:base="http://localhost:4000/til/web-Accessibility.html"><![CDATA[<p>웹 접근성(a11y)는 정보에 동등하게 접근하고 이해 할 수 있도록 보장하기 위해 중요하다.</p>

<ul>
  <li><a href="https://story.pxd.co.kr/1588">wai-aria란?</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques">aria 사용방법</a></li>
  <li>리액트 jsx에서 <code class="language-plaintext highlighter-rouge">wai-aria</code>를 지원한다.</li>
  <li><code class="language-plaintext highlighter-rouge">aria-\*</code> 과 같은 어트리뷰트는 kebab-case로 작성해야한다.</li>
</ul>

<h3 id="role">role</h3>

<ul>
  <li>태그의 역할을 알려주는 속성</li>
  <li>정해진 값만 사용하여야 한다.</li>
</ul>

<h3 id="aria-label">aria-label</h3>

<ul>
  <li>스크린 리더기에 전달할 내용을 알려주는 속성</li>
  <li>예를들어, 어코디언이 있으면 펼치기와 같이 <code class="language-plaintext highlighter-rouge">aria-label</code>를 통해 알려줄 수 있다.</li>
  <li>주의할 점은 시멘틱 태그이거나, role 속성 값이 상호작용(interactive)을 하는 값일 때 aria-label을 붙일 수 있다는 것이다.</li>
  <li><a href="https://velog.io/@a_in/WAI-ARIA-role-aria-label">aria-label과 role을 쓰기 위한 규칙</a></li>
</ul>

<h3 id="tabindex">tabindex</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0</code> : 상호작용 가능한 요소 처럼 포커싱이 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">-1</code> : 포커싱에서 제외 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">양수</code> : 강제로 순서를 정한다. 그 이후에 브라우저의 포커싱 순서대로 잡힌다. 무조건 피해야함.</li>
</ul>

<h3 id="img-alt">img alt</h3>

<ul>
  <li>이미지가 나오지 않을 때, 이미지에 대한 설명</li>
</ul>

<h3 id="aria-required">aria-required</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">true</code>인 경우, 스크린 리더기에 필수요소임을 알려주는 속성</li>
</ul>

<p><br /></p>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[웹 접근성(a11y)는 정보에 동등하게 접근하고 이해 할 수 있도록 보장하기 위해 중요하다.]]></summary></entry><entry><title type="html">CSS</title><link href="http://localhost:4000/til/css.html" rel="alternate" type="text/html" title="CSS" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/css</id><content type="html" xml:base="http://localhost:4000/til/css.html"><![CDATA[<h2 id="텍스트에-자연스럽게-gradient-넣기">텍스트에 자연스럽게 gradient 넣기</h2>

<ol>
  <li>
    <p>백그라운드 영역에 먼저 그라디언트를 넣어준다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> background: linear-gradient(to bottom, #194c33, #bbb); // 예시
</code></pre></div>    </div>
  </li>
  <li>
    <p>아래와 같이 속성을 넣어준다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-webkit-background-clip: text; // 텍스트 내부에만 배경 이미지를 적용하도록 지정
-webkit-text-fill-color: transparent; // 글씨 투명하게 지정
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[텍스트에 자연스럽게 gradient 넣기]]></summary></entry></feed>