<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-11T00:51:35+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">parklego dev log</title><subtitle>Build Jekyll site with the GitBook style.
</subtitle><author><name>parklego</name></author><entry><title type="html">Git/Github</title><link href="http://localhost:4000/til/2024-03-01-git-github.html" rel="alternate" type="text/html" title="Git/Github" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/git%20github</id><content type="html" xml:base="http://localhost:4000/til/2024-03-01-git-github.html"><![CDATA[<h2 id="jekyll을-사용하여-github-pages-배포-및-테마적용">Jekyll을 사용하여 GitHub Pages 배포 및 테마적용</h2>

<blockquote>
  <p>사전 준비</p>
</blockquote>

<ul>
  <li>Ruby 설치</li>
  <li>Jekyll 설치</li>
  <li>테마 선택
    <ul>
      <li><a href="http://jamstackthemes.dev">jamstackthemes.dev</a></li>
      <li><a href="http://jekyllthemes.org/">http://jekyllthemes.org/</a></li>
    </ul>
  </li>
  <li>코드블럭 선택
    <ul>
      <li><a href="https://spsarolkar.github.io/rouge-theme-preview/">https://spsarolkar.github.io/rouge-theme-preview/</a>
<br /></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>배포 및 테마 적용하기</p>
</blockquote>

<ol>
  <li>
    <p>github repository 생성</p>

    <ul>
      <li>repository명은 github 아이디.github.io로 생성할 것</li>
      <li>repository는 public 으로 할 것</li>
      <li>ex) parklego.github.io</li>
    </ul>
  </li>
  <li>
    <p>bundle 명령어 실행</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bundle</span> <span class="nx">install</span>
<span class="nx">bundle</span> <span class="nx">exec</span> <span class="nx">jekyll</span> <span class="nx">serve</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>블로그 설정</p>
    <ul>
      <li>_conif.yml 파일에서 제목이나 이름 등을 변경</li>
      <li>_posts 폴더에 원하는 게시글 작성 (yyy-mm-dd 형태)</li>
    </ul>
  </li>
</ol>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[Jekyll을 사용하여 GitHub Pages 배포 및 테마적용]]></summary></entry><entry><title type="html">JWT 적용기</title><link href="http://localhost:4000/til/2024-03-01-jwt.html" rel="alternate" type="text/html" title="JWT 적용기" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/jwt</id><content type="html" xml:base="http://localhost:4000/til/2024-03-01-jwt.html"><![CDATA[<blockquote>
  <p>사전 준비</p>
</blockquote>

<ol>
  <li>cookie parser</li>
  <li>cors
    <ul>
      <li>origin 설정</li>
      <li>credentials true</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<blockquote>
  <p>JWT 로직</p>
</blockquote>

<ul>
  <li>
    <p>로그인 시 인증 서버로부터 access token, refresh token을 쿠키에 넣어서 보내준다.</p>

    <p>(중요) refresh token은 httpOnly / secure / SameSite 옵션을 준다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">maxAge</span><span class="p">:</span> <span class="mi">300000</span><span class="p">,</span> <span class="c1">// 5m</span>
  <span class="nx">httpOnly</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">secure</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">sameSite</span><span class="p">:</span> <span class="dl">"</span><span class="s2">strict</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>인증 체계를 다음과 같이 만든다.</p>

    <ol>
      <li>
        <p>쿠키에 엑세스토큰이 있는지 확인한다.</p>

        <ul>
          <li>엑세스 토큰이 없다면 엑세스토큰을 재발급 절차를 받는다. (2번으로 이동)</li>
          <li>엑세스 토큰 있다면 엑세스토큰을 확인 절차를 밟는다. (종료)</li>
        </ul>
      </li>
      <li>
        <p>재발급을 받는 절차에서 리프레시 토큰을 확인한다.</p>
        <ul>
          <li>리프레시 토큰이 없거나 유효하지 않으면 로그인 페이지로 이동시킨다. (종료)</li>
          <li>리프레시 토큰이 유효하다면 새로운 엑세스토큰을 발급해준다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><br />
<br /></p>

<p>token의 저장 위치에 관하여는 언제나 말이 많았다. 예전에 나는 localstorage에 저장해서 이번에는 cookie에 한 번 담아 본 것이다.</p>

<p>리액트같은 경우에 access token을 private 변수로 저장해놓고 사용해도 된다고 한다. 왜냐하면 어차피 refresh token이 있으니까 재발급받으면 된다는 의미인 것 같았다.</p>

<p>refresh token을 일회성으로 사용하는 RTR (Refresh Token Rotation)이라는 방법도 있다.</p>

<p>그러고 보니 access token을 헤더에 실어 보낼 때 어떻게 했더라 싶어서 다시 찾아봤다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">accessToken</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">accessToken</span><span class="dl">"</span><span class="p">)</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">requestData</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nx">axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="dl">"</span><span class="s2">http://localhost:8000/like</span><span class="dl">"</span><span class="p">,</span> <span class="nx">requestData</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">Authorization</span><span class="p">:</span> <span class="s2">`Bearer </span><span class="p">${</span><span class="nx">accessToken</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">});</span>
</code></pre></div></div>

<p>아. 그리고 Bearer를 항상 붙였었는데 이건 일종의 약속이라서 그렇다고 한다.</p>

<p><code class="language-plaintext highlighter-rouge">Authorization: &lt;type&gt; &lt;credentials&gt;</code></p>

<p>Bearer 타입은 JWT 혹은 OAuth에 대한 토큰을 사용한다는 뜻.</p>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[사전 준비]]></summary></entry><entry><title type="html">네트워크</title><link href="http://localhost:4000/til/2024-03-01-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.html" rel="alternate" type="text/html" title="네트워크" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC</id><content type="html" xml:base="http://localhost:4000/til/2024-03-01-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.html"><![CDATA[<h2 id="rest-api란-무엇인가">REST API란 무엇인가?</h2>

<p>REST API란 REST를 기반으로 만들어진 API를 의미한다. REST API를 알기 위해 REST부터 알아야 한다.</p>

<h3 id="rest">REST</h3>

<p>REST(Representational State Transfer)의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미.</p>

<p>HTTP URI를 통해 자원을 명시하고, HTTP Method (POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD OPERATION을 적용하는 것을 의미한다.</p>

<p><br /></p>

<blockquote>
  <p>참고 : PUT vs PATCH</p>
</blockquote>

<ul>
  <li>PUT : 리소스의 모든 것을 업데이트 한다. 덮어씌운다는 느낌. 보내지 않은 데이터는 null로 반환.</li>
  <li>PATCH : 리소스의 일부를 업데이트 한다. 일부를 수정하는 느낌. 보낸 데이터만 수정됨.</li>
</ul>

<h3 id="rest-api">REST API</h3>

<p>REST의 원리를 따르는 API.</p>

<ol>
  <li>URL은 동사보다는 명사, 대문자보다는 소문자를 사용한다.</li>
  <li>슬래시(/)는 계층 관계를 나타내는데 사용한다.</li>
  <li>마지막은 슬래시(/)를 포함하지 않는다.</li>
  <li>언더바(_)대신 하이픈(-)을 사용한다.</li>
  <li>파일확장자는 URL에 포함하지 않는다.</li>
</ol>

<p>또한, REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함되어야 한다.</p>

<p><br /></p>

<blockquote>
  <p>자주 사용되는 상태코드</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">상태코드</th>
      <th style="text-align: center">상태</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">200</td>
      <td style="text-align: center">OK</td>
      <td>서버가 요청을 성공적으로 처리하였다.</td>
    </tr>
    <tr>
      <td style="text-align: center">201</td>
      <td style="text-align: center">Created</td>
      <td>요청이 처리되어서 새로운 리소스가 생성되었다.</td>
    </tr>
    <tr>
      <td style="text-align: center">202</td>
      <td style="text-align: center">Accepted</td>
      <td>요청은 접수하였지만, 처리가 완료되지 않았다.</td>
    </tr>
    <tr>
      <td style="text-align: center">400</td>
      <td style="text-align: center">Bad Request</td>
      <td>서버가 요청을 성공적으로 처리하였다.</td>
    </tr>
    <tr>
      <td style="text-align: center">401</td>
      <td style="text-align: center">Unauthorized</td>
      <td>지정한 리소스에 대한 액세스 권한이 없다.</td>
    </tr>
    <tr>
      <td style="text-align: center">403</td>
      <td style="text-align: center">Forbidden</td>
      <td>지정한 리소스에 대한 액세스가 금지되었다.</td>
    </tr>
    <tr>
      <td style="text-align: center">404</td>
      <td style="text-align: center">Not Found</td>
      <td>지정한 리소스를 찾을 수 없다.</td>
    </tr>
    <tr>
      <td style="text-align: center">500</td>
      <td style="text-align: center">Internal Server Error</td>
      <td>서버에 에러가 발생하였다.</td>
    </tr>
    <tr>
      <td style="text-align: center">501</td>
      <td style="text-align: center">Not Implemented</td>
      <td>요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다.</td>
    </tr>
    <tr>
      <td style="text-align: center">502</td>
      <td style="text-align: center">Bad Gateway</td>
      <td>웹서버가 다른 서버로부터의 잘못된 응답을 받았을 때 발생한다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<blockquote>
  <p>참고 : 4xx vs 5xx</p>
</blockquote>

<ul>
  <li>4xx : 클라이언트 에러</li>
  <li>5xx : 서버 에러</li>
</ul>

<h3 id="restful">RESTful</h3>

<p>REST API의 모든 설계 규칙을 올바르게 지킨 시스템을 <code class="language-plaintext highlighter-rouge">RESTful하다</code> 라고 한다.</p>

<hr />

<p><a href="https://khj93.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-REST-API%EB%9E%80-REST-RESTful%EC%9D%B4%EB%9E%80">REST API란</a></p>

<p><a href="https://velog.io/@somday/RESTful-API-%EC%9D%B4%EB%9E%80">RESTful API란</a></p>

<p><a href="https://meetup.nhncloud.com/posts/92">REST API 제대로 알고 사용하기</a></p>

<p><a href="https://hongong.hanbit.co.kr/http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C-%ED%91%9C-1xx-5xx-%EC%A0%84%EC%B2%B4-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/">http 상태코드</a></p>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[REST API란 무엇인가?]]></summary></entry><entry><title type="html">React</title><link href="http://localhost:4000/til/2024-03-01-%EB%A6%AC%EC%95%A1%ED%8A%B8.html" rel="alternate" type="text/html" title="React" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/%EB%A6%AC%EC%95%A1%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/til/2024-03-01-%EB%A6%AC%EC%95%A1%ED%8A%B8.html"><![CDATA[<h2 id="input-컴포넌트-만들기">Input 컴포넌트 만들기</h2>

<p>공용 컴포넌트 중 Input 컴포넌트를 만들어 보기로 했다.</p>

<p>처음에는 input에 필요한 속성값들을 하나하나 다 넣어주어야 싶었다. input 컴포넌트를 어떤 식으로 개발하면 좋을까 찾아보다가 2023년에 유행했던 ui 라이브러리인 shadcn의 소스를 까보기로 하였다.</p>

<p>shadcn과 같이 input에 여러 속성 값이 있는데 타입스크립트에서 지원하는 <em>InputHTMLAttributes을 이용하여 넣어주고, 필요한 props는 interface로 추가해서 보완하였다.</em></p>

<p>이렇게 만든 Input 컴포넌트들을 유효성을 검사하기 위해 Input form 컴포넌트를 react-hook-form과 zod를 엮어서 만들었다.</p>

<p>react-hook-form의 기능들을 자식 컴포넌트에 접근 가능케 하기위해 <code class="language-plaintext highlighter-rouge">forwardRef</code>로 감싸야 한다는 것을 알았다.</p>

<p><br /></p>

<blockquote>
  <p>Input 컴포넌트 만들 때 주의사항</p>
</blockquote>

<ul>
  <li>label 태그를 꼭 넣어주자. 그리고 <code class="language-plaintext highlighter-rouge">label</code>태그를 다음 input 컴포넌트와 연결해주어야 한다.</li>
  <li>그러면 label을 눌렀을때 input 컴포넌트로 포커싱이 되어 접근성 측면에서도 좋다.</li>
  <li>리액트에서는 <code class="language-plaintext highlighter-rouge">for</code>대신 <code class="language-plaintext highlighter-rouge">htmlFor</code>을 사용한다. 값은 input 컴포넌트의 <code class="language-plaintext highlighter-rouge">id</code>값을 따라간다.</li>
  <li><code class="language-plaintext highlighter-rouge">autofocus</code>속성도 있다.</li>
</ul>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[Input 컴포넌트 만들기]]></summary></entry><entry><title type="html">웹 접근성</title><link href="http://localhost:4000/til/2024-03-01-%EC%9B%B9-%EC%A0%91%EA%B7%BC%EC%84%B1.html" rel="alternate" type="text/html" title="웹 접근성" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/%EC%9B%B9%20%EC%A0%91%EA%B7%BC%EC%84%B1</id><content type="html" xml:base="http://localhost:4000/til/2024-03-01-%EC%9B%B9-%EC%A0%91%EA%B7%BC%EC%84%B1.html"><![CDATA[<p>웹 접근성(a11y)는 정보에 동등하게 접근하고 이해 할 수 있도록 보장하기 위해 중요하다.</p>

<ul>
  <li><a href="https://story.pxd.co.kr/1588">wai-aria란?</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques">aria 사용방법</a></li>
  <li>리액트 jsx에서 <code class="language-plaintext highlighter-rouge">wai-aria</code>를 지원한다.</li>
  <li><code class="language-plaintext highlighter-rouge">aria-\*</code> 과 같은 어트리뷰트는 kebab-case로 작성해야한다.</li>
</ul>

<h3 id="role">role</h3>

<ul>
  <li>태그의 역할을 알려주는 속성</li>
  <li>정해진 값만 사용하여야 한다.</li>
</ul>

<h3 id="aria-label">aria-label</h3>

<ul>
  <li>스크린 리더기에 전달할 내용을 알려주는 속성</li>
  <li>예를들어, 어코디언이 있으면 펼치기와 같이 <code class="language-plaintext highlighter-rouge">aria-label</code>를 통해 알려줄 수 있다.</li>
  <li>주의할 점은 시멘틱 태그이거나, role 속성 값이 상호작용(interactive)을 하는 값일 때 aria-label을 붙일 수 있다는 것이다.</li>
  <li><a href="https://velog.io/@a_in/WAI-ARIA-role-aria-label">aria-label과 role을 쓰기 위한 규칙</a></li>
</ul>

<h3 id="tabindex">tabindex</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0</code> : 상호작용 가능한 요소 처럼 포커싱이 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">-1</code> : 포커싱에서 제외 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">양수</code> : 강제로 순서를 정한다. 그 이후에 브라우저의 포커싱 순서대로 잡힌다. 무조건 피해야함.</li>
</ul>

<h3 id="img-alt">img alt</h3>

<ul>
  <li>이미지가 나오지 않을 때, 이미지에 대한 설명</li>
</ul>

<h3 id="aria-required">aria-required</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">true</code>인 경우, 스크린 리더기에 필수요소임을 알려주는 속성</li>
</ul>

<p><br /></p>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[웹 접근성(a11y)는 정보에 동등하게 접근하고 이해 할 수 있도록 보장하기 위해 중요하다.]]></summary></entry><entry><title type="html">생각정리</title><link href="http://localhost:4000/til/2024-03-01-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%A9%B4%EC%84%9C%EC%83%9D%EA%B8%B4%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4.html" rel="alternate" type="text/html" title="생각정리" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/%EA%B0%9C%EB%B0%9C%ED%95%98%EB%A9%B4%EC%84%9C%EC%83%9D%EA%B8%B4%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4</id><content type="html" xml:base="http://localhost:4000/til/2024-03-01-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%A9%B4%EC%84%9C%EC%83%9D%EA%B8%B4%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4.html"><![CDATA[<h2 id="라이트다크-모드">라이트/다크 모드</h2>

<p>최근에 create-react-app을 더 이상 사용하지 않는다는 소식을 들었다. 그래서 다음에는 vite를 이용해보고자 했는데 드디어 사용해보게 되었다.</p>

<p>새로 해보는 만큼 라이브러리도 써보지 않은 다양한 것을 사용해보고 싶었다. 그래서 shadcn도 설정하였다.</p>

<p>설정하는 단계가 조금 귀찮다. 그리고 문서가 자세하지가 않다. 그렇지만 이쁘다.</p>

<p>그리고 상태관리로는 최근에 가장 가파른 상승세를 타고 있는 zustand를 사용해보기로 했다.</p>

<p>처음에 해보고 싶었던 것은 라이트/다크모드를 설정해보는 기능을 구현해보고 싶었다.</p>

<p>localstorage를 이용해서 구현할 것이고, styled-component의 <code class="language-plaintext highlighter-rouge">themeProvider</code>로 구현하고자 하였다.</p>

<p>그런데 zustand에 localstorage가 있었다. 그래서 persist middleware와 함께 이용하기로 했다.</p>

<p>shadcn의 switch 컴포넌트를 이용해 토글기능으로 다크모드를 on/off 하였다. 그러다 ux측면도 고려해보게 되었다.</p>

<p>내가 주로 검색하는데 사용하는 phind와 shadcn의 다크모드 기능을 살펴보았다.</p>

<ul>
  <li>phind의 경우에는 처음에 os의 테마를 바탕으로 사이트를 변경해준다. 이때 localstorage에는 테마의 키-벨류가 없다. 그리고 유저가 테마를 건드리면 그때 키-벨류값이 생기고 이에따라 테마가 변경된다.</li>
  <li>shadcn의 경우 처음부터 라이트/다크/시스템 이렇게 선택할 수 있게 설정이 되어 있다.</li>
</ul>

<p>다크모드 구현이 단순한 기능인줄 알았는데 생각보다 다양한 방법도 있다는 것을 알았다. UX도 생각보다 빠르게 발전하고 있구나 싶었다.</p>

<p>os 테마변경에 따른 실시간 변경을 위해 커스텀훅을 만들어서 구현하였다.</p>]]></content><author><name>parklego</name></author><category term="til" /><summary type="html"><![CDATA[라이트/다크 모드]]></summary></entry></feed>