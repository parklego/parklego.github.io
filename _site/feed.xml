<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-05T22:19:08+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">parklego dev log</title><subtitle>Build Jekyll site with the GitBook style.
</subtitle><author><name>parklego</name></author><entry><title type="html">2024-03-TIL</title><link href="http://localhost:4000/til/2024-03-01-til.html" rel="alternate" type="text/html" title="2024-03-TIL" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/til/til</id><content type="html" xml:base="http://localhost:4000/til/2024-03-01-til.html"><![CDATA[<h2 id="jekyll을-사용하여-github-pages-배포-및-테마적용">Jekyll을 사용하여 GitHub Pages 배포 및 테마적용</h2>

<blockquote>
  <p>사전 준비</p>
</blockquote>

<ul>
  <li>Ruby 설치</li>
  <li>Jekyll 설치</li>
  <li>테마 선택
    <ul>
      <li><a href="http://jamstackthemes.dev">jamstackthemes.dev</a></li>
      <li><a href="http://jekyllthemes.org/">http://jekyllthemes.org/</a></li>
    </ul>
  </li>
  <li>코드블럭 선택
    <ul>
      <li><a href="https://spsarolkar.github.io/rouge-theme-preview/">https://spsarolkar.github.io/rouge-theme-preview/</a>
<br /></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>배포 및 테마 적용하기</p>
</blockquote>

<ol>
  <li>
    <p>github repository 생성</p>

    <ul>
      <li>repository명은 github 아이디.github.io로 생성할 것</li>
      <li>repository는 public 으로 할 것</li>
      <li>ex) parklego.github.io</li>
    </ul>
  </li>
  <li>
    <p>bundle 명령어 실행</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bundle</span> <span class="nx">install</span>
<span class="nx">bundle</span> <span class="nx">exec</span> <span class="nx">jekyll</span> <span class="nx">serve</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>블로그 설정</p>
    <ul>
      <li>_conif.yml 파일에서 제목이나 이름 등을 변경</li>
      <li>_posts 폴더에 원하는 게시글 작성 (yyy-mm-dd 형태)</li>
    </ul>
  </li>
</ol>

<h2 id="웹-접근성">웹 접근성</h2>

<p>웹 접근성(a11y)는 정보에 동등하게 접근하고 이해 할 수 있도록 보장하기 위해 중요하다.</p>

<ul>
  <li><a href="https://story.pxd.co.kr/1588">wai-aria란?</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques">aria 사용방법</a></li>
  <li>리액트 jsx에서 <code class="language-plaintext highlighter-rouge">wai-aria</code>를 지원한다.</li>
  <li><code class="language-plaintext highlighter-rouge">aria-\*</code> 과 같은 어트리뷰트는 kebab-case로 작성해야한다.</li>
</ul>

<h3 id="role">role</h3>

<ul>
  <li>태그의 역할을 알려주는 속성</li>
  <li>정해진 값만 사용하여야 한다.</li>
</ul>

<h3 id="aria-label">aria-label</h3>

<ul>
  <li>스크린 리더기에 전달할 내용을 알려주는 속성</li>
  <li>예를들어, 어코디언이 있으면 펼치기와 같이 <code class="language-plaintext highlighter-rouge">aria-label</code>를 통해 알려줄 수 있다.</li>
  <li>주의할 점은 시멘틱 태그이거나, role 속성 값이 상호작용(interactive)을 하는 값일 때 aria-label을 붙일 수 있다는 것이다.</li>
  <li><a href="https://velog.io/@a_in/WAI-ARIA-role-aria-label">aria-label과 role을 쓰기 위한 규칙</a></li>
</ul>

<h3 id="tabindex">tabindex</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0</code> : 상호작용 가능한 요소 처럼 포커싱이 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">-1</code> : 포커싱에서 제외 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">양수</code> : 강제로 순서를 정한다. 그 이후에 브라우저의 포커싱 순서대로 잡힌다. 무조건 피해야함.</li>
</ul>

<h3 id="img-alt">img alt</h3>

<ul>
  <li>이미지가 나오지 않을 때, 이미지에 대한 설명</li>
</ul>

<h3 id="aria-required">aria-required</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">true</code>인 경우, 스크린 리더기에 필수요소임을 알려주는 속성</li>
</ul>

<h2 id="ssr과-csr-차이">SSR과 CSR 차이</h2>

<p><img src="https://d2.naver.com/content/images/2020/06/ssr.png" alt="img" /></p>

<ol>
  <li>서버단에서 내용을 채워넣은 뒤 (서버에서 랜더링) 응답 값으로 이를 보내준다.</li>
  <li>브라우저에서 채워넣은 내용을 볼 수 있다. 브라우저에서 js를 다운 받는다.</li>
  <li>브라우저에서 다운로드 받은 js를 실행한다.</li>
  <li>페이지에서 상호작용을 할 수 있다.</li>
</ol>

<p><br />
<br /></p>

<p><img src="https://d2.naver.com/content/images/2020/06/csr.png" alt="img" /></p>

<ol>
  <li>서버단에서 껍데기를 보내준다.</li>
  <li>브라우저에서 js를 다운 받는다.</li>
  <li>브라우저에서 다운로드 받은 js를 실행한다.</li>
  <li>실행되면서 페이지에 그려지고, 이때 상호작용을 할 수 있다.</li>
</ol>

<p><br /></p>

<h2 id="검색엔진-최적화seo">검색엔진 최적화(SEO)</h2>

<h3 id="ssr">SSR</h3>

<p>가장 좋은 방법은 SSR을 이용하는 것이다.</p>

<p>검색 봇은 크롤링을 하는데 CSR은 내용을 볼 수 없기 때문에 SEO에 취약하다.
그렇다면 React에서는 이를 어떻게 보완할 수 있을까?</p>

<h3 id="메타태그">메타태그</h3>

<p>메타 태그와 og태그(오픈그래프)를 사용해야한다.
그 중에 가장 중요한 태그는 <code class="language-plaintext highlighter-rouge">title</code>,<code class="language-plaintext highlighter-rouge">description</code>,<code class="language-plaintext highlighter-rouge">robots</code>,<code class="language-plaintext highlighter-rouge">charset</code>,<code class="language-plaintext highlighter-rouge">viewport</code></p>

<h3 id="robotstxt">robots.txt</h3>

<p>검색 엔진 크롤러가 웹 사이트를 적절하게 색인하도록 지시하고, 부적절한 콘텐츠를 제한하여 SEO를 개선할 수 있다.</p>

<h3 id="sitemapxml">sitemap.xml</h3>

<p>웹사이트에 새로운 콘텐츠가 발행될 때마다 해당 URL을 사이트맵에 추가하여 주기적으로 사이트맵을 업데이트하는 것이 필요</p>

<h3 id="서치콘솔-등록">서치콘솔 등록</h3>

<ul>
  <li>Google Search Console</li>
  <li>네이버 서치어드바이저</li>
</ul>

<h3 id="https">https</h3>

<p>구글은 보안 프로토콜을 적용한 웹사이트에게 적용하지 않은 웹사이트(HTTP)보다 더 높은 점수를 부여할 것이라고 발표</p>

<h3 id="모바일-친화성-갖추기">모바일 친화성 갖추기</h3>

<p>구글은 2018년부터 본격적으로 모바일 중심 색인 생성을 시작</p>

<h3 id="react-snap">react-snap</h3>

<ul>
  <li>Prerendering.</li>
  <li>유지보수가 중단되었다고 한다..</li>
</ul>

<h3 id="react-helmet">react-helmet</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 섹션을 동적으로 관리하기 위한 라이브러리</li>
  <li>페이지 별로 메타데이터를 설정해 줄 수 있다.</li>
</ul>

<p><br /></p>

<h4 id="읽어보면-좋은-자료">읽어보면 좋은 자료</h4>

<p><a href="https://www.youtube.com/watch?v=D71ByEIBWEs">SSR과 CSR 이 영상 하나로 끝내기</a></p>

<p><a href="https://d2.naver.com/helloworld/7804182">SSR 도입</a></p>]]></content><author><name>parklego</name></author><category term="TIL" /><summary type="html"><![CDATA[Jekyll을 사용하여 GitHub Pages 배포 및 테마적용]]></summary></entry><entry><title type="html">UI Library</title><link href="http://localhost:4000/library/2024-03-01-ui%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC.html" rel="alternate" type="text/html" title="UI Library" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/library/ui%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/library/2024-03-01-ui%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC.html"><![CDATA[<h2 id="tui-editor">Tui-editor</h2>

<p>편집기를 사용하면 텍스트 또는 WYSIWYG를 사용하여 Markdown 문서를 편집할 수 있으며 구문 강조, 스크롤 동기화, 실시간 미리 보기 및 차트 기능이 함께 제공하는 라이브러리</p>

<p><a href="https://ui.toast.com/tui-editor">공식문서</a></p>

<h2 id="frogress">Frogress</h2>

<p>1% 이하의 수를 표현하거나 그라디언트를 넣을 경우 자연스럽게 보이게 하기 위한 progress bar 라이브러리</p>

<p><a href="https://frogress.vercel.app/">공식문서</a></p>

<h2 id="sweetalert2">SweetAlert2</h2>

<p>아이콘, 애니메이션 등 예쁜 alert 라이브러리</p>

<p><a href="https://fkhadra.github.io/react-toastify/introduction/">공식문서</a></p>

<h2 id="hamburger-react">Hamburger-react</h2>

<p>햄버거 버튼 라이브러리</p>

<p><a href="https://hamburger-react.netlify.app/">공식문서</a></p>

<h2 id="react-spinners">React Spinners</h2>

<p>spinners and loader 라이브러리</p>

<p><a href="https://mhnpd.github.io/react-loader-spinner/docs/intro/">공식문서</a></p>

<h2 id="react-toastify">React-toastify</h2>

<p>간단한 toast 라이브러리</p>

<p><a href="https://fkhadra.github.io/react-toastify/introduction/">공식문서</a></p>

<h2 id="react-icons">React-icons</h2>

<p>간단한 icons 라이브러리</p>

<p><a href="https://react-icons.github.io/react-icons/">공식문서</a></p>]]></content><author><name>parklego</name></author><category term="library" /><summary type="html"><![CDATA[Tui-editor]]></summary></entry><entry><title type="html">ETC Library</title><link href="http://localhost:4000/library/2024-03-01-%EA%B7%B8%EC%99%B8%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC.html" rel="alternate" type="text/html" title="ETC Library" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/library/%EA%B7%B8%EC%99%B8%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/library/2024-03-01-%EA%B7%B8%EC%99%B8%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC.html"><![CDATA[<h2 id="zod">Zod</h2>

<p>스키마 선언 및 유효성 검사 라이브러리</p>

<p><a href="https://zod.dev/">공식문서</a></p>

<h2 id="react-hook-form">React-hook-form</h2>

<p>검증 기능을 갖춘 유연하고 확장 가능한 form 라이브러리</p>

<p><a href="https://react-hook-form.com/">공식문서</a></p>]]></content><author><name>parklego</name></author><category term="library" /><summary type="html"><![CDATA[Zod]]></summary></entry><entry><title type="html">2024-02-TIL</title><link href="http://localhost:4000/til/2024-02-01-til.html" rel="alternate" type="text/html" title="2024-02-TIL" /><published>2024-02-01T00:00:00+09:00</published><updated>2024-02-01T00:00:00+09:00</updated><id>http://localhost:4000/til/til</id><content type="html" xml:base="http://localhost:4000/til/2024-02-01-til.html"><![CDATA[<h2 id="라이트다크-모드">라이트/다크 모드</h2>

<p>최근에 create-react-app을 더 이상 사용하지 않는다는 소식을 들었다. 그래서 다음에는 vite를 이용해보고자 했는데 드디어 사용해보게 되었다.</p>

<p>새로 해보는 만큼 라이브러리도 써보지 않은 다양한 것을 사용해보고 싶었다. 그래서 shadcn도 설정하였다.</p>

<p>설정하는 단계가 조금 귀찮다. 그리고 문서가 자세하지가 않다. 그렇지만 이쁘다.</p>

<p>그리고 상태관리로는 최근에 가장 가파른 상승세를 타고 있는 zustand를 사용해보기로 했다.</p>

<p>처음에 해보고 싶었던 것은 라이트/다크모드를 설정해보는 기능을 구현해보고 싶었다.</p>

<p>localstorage를 이용해서 구현할 것이고, styled-component의 <code class="language-plaintext highlighter-rouge">themeProvider</code>로 구현하고자 하였다.</p>

<p>그런데 zustand에 localstorage가 있었다. 그래서 persist middleware와 함께 이용하기로 했다.</p>

<p>shadcn의 switch 컴포넌트를 이용해 토글기능으로 다크모드를 on/off 하였다. 그러다 ux측면도 고려해보게 되었다.</p>

<p>내가 주로 검색하는데 사용하는 phind와 shadcn의 다크모드 기능을 살펴보았다.</p>

<ul>
  <li>phind의 경우에는 처음에 os의 테마를 바탕으로 사이트를 변경해준다. 이때 localstorage에는 테마의 키-벨류가 없다. 그리고 유저가 테마를 건드리면 그때 키-벨류값이 생기고 이에따라 테마가 변경된다.</li>
  <li>shadcn의 경우 처음부터 라이트/다크/시스템 이렇게 선택할 수 있게 설정이 되어 있다.</li>
</ul>

<p>다크모드 구현이 단순한 기능인줄 알았는데 생각보다 다양한 방법도 있다는 것을 알았다. UX도 생각보다 빠르게 발전하고 있구나 싶었다.</p>

<p>os 테마변경에 따른 실시간 변경을 위해 커스텀훅을 만들어서 구현하였다.</p>

<h2 id="input-컴포넌트-만들기">Input 컴포넌트 만들기</h2>

<p>공용 컴포넌트 중 Input 컴포넌트를 만들어 보기로 했다.</p>

<p>처음에는 input에 필요한 속성값들을 하나하나 다 넣어주어야 싶었다. input 컴포넌트를 어떤 식으로 개발하면 좋을까 찾아보다가 2023년에 유행했던 ui 라이브러리인 shadcn의 소스를 까보기로 하였다.</p>

<p>shadcn과 같이 input에 여러 속성 값이 있는데 타입스크립트에서 지원하는 <em>InputHTMLAttributes을 이용하여 넣어주고, 필요한 props는 interface로 추가해서 보완하였다.</em></p>

<p>이렇게 만든 Input 컴포넌트들을 유효성을 검사하기 위해 Input form 컴포넌트를 react-hook-form과 zod를 엮어서 만들었다.</p>

<p>react-hook-form의 기능들을 자식 컴포넌트에 접근 가능케 하기위해 <code class="language-plaintext highlighter-rouge">forwardRef</code>로 감싸야 한다는 것을 알았다.</p>

<h3 id="input-컴포넌트-만들-때-주의사항">Input 컴포넌트 만들 때 주의사항</h3>

<ul>
  <li>label 태그를 꼭 넣어주자. 그리고 <code class="language-plaintext highlighter-rouge">label</code>태그를 다음 input 컴포넌트와 연결해주어야 한다.</li>
  <li>그러면 label을 눌렀을때 input 컴포넌트로 포커싱이 되어 접근성 측면에서도 좋다.</li>
  <li>리액트에서는 <code class="language-plaintext highlighter-rouge">for</code>대신 <code class="language-plaintext highlighter-rouge">htmlFor</code>을 사용한다. 값은 input 컴포넌트의 <code class="language-plaintext highlighter-rouge">id</code>값을 따라간다.</li>
  <li><code class="language-plaintext highlighter-rouge">autofocus</code>속성도 있다.</li>
</ul>]]></content><author><name>parklego</name></author><category term="TIL" /><summary type="html"><![CDATA[라이트/다크 모드]]></summary></entry></feed>