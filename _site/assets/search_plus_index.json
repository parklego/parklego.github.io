{"/pages/about": {
    "title": "About",
    "keywords": "self",
    "url": "/pages/about",
    "body": "안녕하세요, 반갑습니다! 😊 이곳은 제가 개발과 관련된 내용을 간단히 기록하는 곳입니다. 주로 TIL에 대한 내용입니다. [ 나의 인기글 ] var, let, const 차이점 이때 첫 포스터였는데 16만명이 방문한 글이라 뜻깊은 포스터 [ 개발하면서 보면 좋은 자료들 링크 모음 ] stateofjs 프로그래머스리포트 카카오FE기술블로그 우아한기술블로그 toastUI [과거 흔적] 벨로그 티스토리"
  },"/pages/library": {
    "title": "라이브러리 추천",
    "keywords": "library",
    "url": "/pages/library",
    "body": "use-debounce hook 형태로 간단하게 디바운스 기능을 구현하는 라이브러리 공식문서 Tui-editor 편집기를 사용하면 텍스트 또는 WYSIWYG를 사용하여 Markdown 문서를 편집할 수 있으며 구문 강조, 스크롤 동기화, 실시간 미리 보기 및 차트 기능이 함께 제공하는 라이브러리 공식문서 Frogress 1% 이하의 수를 표현하거나 그라디언트를 넣을 경우 자연스럽게 보이게 하기 위한 progress bar 라이브러리 공식문서 SweetAlert2 아이콘, 애니메이션 등 예쁜 alert 라이브러리 공식문서 Hamburger-react 햄버거 버튼 라이브러리 공식문서 React Spinners spinners and loader 라이브러리 공식문서 React-toastify 간단한 toast 라이브러리 공식문서 React-hot-toast 간단한 toast 라이브러리2 공식문서 React-icons 간단한 icons 라이브러리 공식문서 Swiper swiper 라이브러리 공식문서"
  },"/pages/resources": {
    "title": "리소스 추천",
    "keywords": "resources",
    "url": "/pages/resources",
    "body": "iconfinder icon들을 png나 svg로 간단하게 찾아볼 수 있는 사이트 공식문서"
  },"/til/think.html": {
    "title": "개발일지",
    "keywords": "til",
    "url": "/til/think.html",
    "body": "라이트/다크 모드 최근에 create-react-app을 더 이상 사용하지 않는다는 소식을 들었다. 그래서 다음에는 vite를 이용해보고자 했는데 드디어 사용해보게 되었다. 새로 해보는 만큼 라이브러리도 써보지 않은 다양한 것을 사용해보고 싶었다. 그래서 shadcn도 설정하였다. 설정하는 단계가 조금 귀찮다. 그리고 문서가 자세하지가 않다. 그렇지만 이쁘다. 그리고 상태관리로는 최근에 가장 가파른 상승세를 타고 있는 zustand를 사용해보기로 했다. 처음에 해보고 싶었던 것은 라이트/다크모드를 설정해보는 기능을 구현해보고 싶었다. localstorage를 이용해서 구현할 것이고, styled-component의 themeProvider로 구현하고자 하였다. 그런데 zustand에 localstorage가 있었다. 그래서 persist middleware와 함께 이용하기로 했다. shadcn의 switch 컴포넌트를 이용해 토글기능으로 다크모드를 on/off 하였다. 그러다 ux측면도 고려해보게 되었다. 내가 주로 검색하는데 사용하는 phind와 shadcn의 다크모드 기능을 살펴보았다. phind의 경우에는 처음에 os의 테마를 바탕으로 사이트를 변경해준다. 이때 localstorage에는 테마의 키-벨류가 없다. 그리고 유저가 테마를 건드리면 그때 키-벨류값이 생기고 이에따라 테마가 변경된다. shadcn의 경우 처음부터 라이트/다크/시스템 이렇게 선택할 수 있게 설정이 되어 있다. 다크모드 구현이 단순한 기능인줄 알았는데 생각보다 다양한 방법도 있다는 것을 알았다. UX도 생각보다 빠르게 발전하고 있구나 싶었다. os 테마변경에 따른 실시간 변경을 위해 커스텀훅을 만들어서 구현하였다. 인터렉티브 프론트엔드 개발자라면 인터렉티브한 웹사이트를 보게되면 이벤트를 발생시켜보면서 어떻게 구현했나? 궁금하고 신기해 한다. 간혹 채용 공고의 우대사항에서도 three.js 사용해본 경험이라던지 R3F에 대한 내용이 더러 있다. 언젠가는 애플과 같은 (스크롤을 감지하여 배경화면을 랜더링) 이쁘고 깔끔한 개발을 해보고 싶다는 생각이 있었는데 최근에 다양한 기술로 가볍게 만들어본 프로젝트의 배경이 생각이 났다. 그래서 three.js를 찍먹이나 해보자는 생각으로 시도를 해보았다. 아래는 우와! 소리가 절로 나올만한 사이트들이다. 드래그를 하면 마우스를 추적하여 꽃이 피어오른다. Nomadic Tribe — makemepulse 30종류의 동물들이 조각형태로 변환되는 것을 보여준다. In Pieces – 30 Species, 30 Pieces. 1 Fragmented Survival. 그 외에 해외에서 다양한 인터렉티브한 사이트들을 한눈에 볼 수 있는 사이트이다. UI도 깔끔하고, 다양한 아이디어들을 볼 수 있어서 좋은 것 같다. CSS Design Awards - Website Awards - Best Web Design Inspiration - CSS Awards https://thefwa.com/awards/page/1/ 찍먹이기에 나는 모델이 마우스 커서를 주시하여 움직이는 정도로만 구현해보고자 했다. 어느정도의 개념적인 부분은 아래에 블로그를 참고 하였고, 내가 구현한 코드를 설명하자면 ... const sensitivity = 1000; useEffect(() =&gt; { const handleMouseMove = (event: MouseEvent) =&gt; { setMousePosition({ x: event.clientY / sensitivity, y: event.clientX / sensitivity, }); }; window.addEventListener(\"mousemove\", handleMouseMove); return () =&gt; { window.removeEventListener(\"mousemove\", handleMouseMove); }; }, []); useFrame((state, delta) =&gt; { meshRef.current.rotation.x = mousePosition.x; meshRef.current.rotation.y = mousePosition.y - 1000; }); ... @react-three/fiber에서 제공하는 useFrame을 사용하여 매 프레임마다 rotation되게 하면 모델을 움직일 수 있게 할 수 있을 것 같았다. 그러기 위해서 마우스의 움직임을 추적해야하는데 이를 위해 handleMouseMove 라는 함수를 만들어 주었다. (useFrame은 애니메이션을 처리하거나 실시간으로 변화하는 값을 관리할 때 주로 사용한다.) 마우스를 좌,우(x축)로 움직였을 때 모델이 위아래로 움직였고 상,하로 움직였을 때 모델이 좌우로 움직였다. 그래서 포지션을 반대로 해주면 될 것 같았다. 그러나 너무 빠르게 움직여서 미친듯이 움직였다. 그래서 민감도를 주기 위하여 그 값을 큰 값으로 나누어서 값의 크기를 줄였더니 원하는대로 움직였다. 하지만 내가 개발한 페이지에서 모델은 오른쪽에 배치를 했기 때문에 가용범위를 고려하여 실제 회전을 할 때에 y값에 -값을 추가해보면서 자연스러운 값을 찾았다. Canvas 위에 Mesh라는 Object를 얹는다는 느낌으로 이해하면 된다. 3D 모델은 아래의 사이트에서 찾아서 불러왔다. https://sketchfab.com/feed JWT 적용기 사전 준비 cookie parser cors origin 설정 credentials true JWT 로직 로그인 시 인증 서버로부터 access token, refresh token을 쿠키에 넣어서 보내준다. (중요) refresh token은 httpOnly / secure / SameSite 옵션을 준다. { maxAge: 300000, // 5m httpOnly: true, secure: true, sameSite: \"strict\" } 인증 체계를 다음과 같이 만든다. 쿠키에 엑세스토큰이 있는지 확인한다. 엑세스 토큰이 없다면 엑세스토큰을 재발급 절차를 받는다. (2번으로 이동) 엑세스 토큰 있다면 엑세스토큰을 확인 절차를 밟는다. (종료) 재발급을 받는 절차에서 리프레시 토큰을 확인한다. 리프레시 토큰이 없거나 유효하지 않으면 로그인 페이지로 이동시킨다. (종료) 리프레시 토큰이 유효하다면 새로운 엑세스토큰을 발급해준다. token의 저장 위치에 관하여는 언제나 말이 많았다. 예전에 나는 localstorage에 저장해서 이번에는 cookie에 한 번 담아 본 것이다. 리액트같은 경우에 access token을 private 변수로 저장해놓고 사용해도 된다고 한다. 왜냐하면 어차피 refresh token이 있으니까 재발급받으면 된다는 의미인 것 같았다. refresh token을 일회성으로 사용하는 RTR (Refresh Token Rotation)이라는 방법도 있다. 그러고 보니 access token을 헤더에 실어 보낼 때 어떻게 했더라 싶어서 다시 찾아봤다. const accessToken = localStorage.getItem(\"accessToken\") || \"\"; const requestData = {}; axios.post(\"http://localhost:8000/like\", requestData, { headers: { Authorization: `Bearer ${accessToken}`, \"Content-Type\": \"application/json\", }, }); 아. 그리고 Bearer를 항상 붙였었는데 이건 일종의 약속이라서 그렇다고 한다. Authorization: &lt;type&gt; &lt;credentials&gt; Bearer 타입은 JWT 혹은 OAuth에 대한 토큰을 사용한다는 뜻. OAuth 2.0으로 Youtube API 호출하기 처음의 나의 로직은 이러했다. next-auth를 이용하여 소셜로그인을 한다. 로그인 도중 oAuth 인증을 통해서 자격증명을 사용자에게 요청한다. 자격증명에 성공하면 Youtube API 접근 권한에 대한 access token을 획득한다. 클라이언트에서 Youtube API를 호출할때 header에 access token을 실어서 넘긴다. // app/api/auth/[...nextauth]/route.ts import NextAuth from \"next-auth\"; import GoogleProvider from \"next-auth/providers/google\"; const handler = NextAuth({ providers: [ GoogleProvider({ clientId: process.env.GOOGLE_CLIENT_ID ?? \"\", clientSecret: process.env.GOOGLE_CLIENT_SECRET ?? \"\", authorization: { params: { scope: \"openid email profile https://www.googleapis.com/auth/youtube.readonly\", prompt: \"consent\", access_type: \"offline\", response_type: \"code\", }, }, }), ], pages: { error: \"/\", }, callbacks: { async jwt({ token, account }) { if (account) { token.accessToken = account.access_token; } return token; }, async session({ session, token, user }) { session.accessToken = token.accessToken; return session; }, }, }); export { handler as GET, handler as POST }; const getChannel = async (keyword) =&gt; { const data = await fetch( `https://www.googleapis.com/youtube/v3/search?part=snippet&amp;type=channel&amp;q=${keyword}`, { headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${session.data.accessToken}`, }, } ); return data.json(); }; 테스트를 해보니 내가 구독한 정보에 대해 잘 불러왔다. 하지만, 문제점은 프로덕션 단계에서 이를 활용하려면 아래와 같이 조건들이 필요했다. 저러한 조건을 다 채우더라도 승인될지의 의문과 구독한 채널의 카테고리를 필터링해서 불러오는 API도 제공하지 않는다. Next-auth 자체가 oAuth를 사용하기때문에 youtube API와 같은 민감한 데이터로의 접근은 프로덕션단계에서만 원활하게 작동한다. 테스트를 하더라도 인증된 이메일만 접근 가능하다. 이는 포기하고 API key로 Youtube API를 호출하는 방식으로 바꿔야 할 듯 하다."
  },"/til/reactNative.html": {
    "title": "React-Native",
    "keywords": "til",
    "url": "/til/reactNative.html",
    "body": "개발환경 셋팅 홈브루 설치 비주얼 스튜디오 코드 설치 Node 설치 자바 SDK 설치 @ 안드로이드 빌드 도구를 위해 설치 Xcode 설치 @ IOS 앱 개발을 위해 설치 코코아팟 설치 @ 오브젝트-c로 구현된 네이티브 모듈 빌드를 위해 설치 @ 원격저장소에 호스팅된 각종 패키지를 받기 위해 설치 워치맨 설치 @ 변경사항 자동 탐지 반영하기 위해 설치 (핫리로딩) 최종 빌드 및 배포를 위해서는 안드로이드 스튜디오와 Xcode를 사용해야 한다. 플러터의 경우에는 네이티브언어가 없으면 자체 엔진으로 네이티브 도구를 이용하지 않고 빌드가 가능하다."
  },"/til/web-Accessibility.html": {
    "title": "웹 접근성",
    "keywords": "til",
    "url": "/til/web-Accessibility.html",
    "body": "웹 접근성(a11y)는 정보에 동등하게 접근하고 이해 할 수 있도록 보장하기 위해 중요하다. wai-aria란? aria 사용방법 리액트 jsx에서 wai-aria를 지원한다. aria-\\* 과 같은 어트리뷰트는 kebab-case로 작성해야한다. role 태그의 역할을 알려주는 속성 정해진 값만 사용하여야 한다. aria-label 스크린 리더기에 전달할 내용을 알려주는 속성 예를들어, 어코디언이 있으면 펼치기와 같이 aria-label를 통해 알려줄 수 있다. 주의할 점은 시멘틱 태그이거나, role 속성 값이 상호작용(interactive)을 하는 값일 때 aria-label을 붙일 수 있다는 것이다. aria-label과 role을 쓰기 위한 규칙 tabindex 0 : 상호작용 가능한 요소 처럼 포커싱이 된다. -1 : 포커싱에서 제외 된다. 양수 : 강제로 순서를 정한다. 그 이후에 브라우저의 포커싱 순서대로 잡힌다. 무조건 피해야함. img alt 이미지가 나오지 않을 때, 이미지에 대한 설명 aria-required true인 경우, 스크린 리더기에 필수요소임을 알려주는 속성"
  },"/til/sass.html": {
    "title": "Sass",
    "keywords": "til",
    "url": "/til/sass.html",
    "body": "Install npm install sass Variables 기본이 되는 변수는 variables.scss 혹은 colors.scss와 같이 관리해주자. 파일을 분리하는 것이 좋다. 참고로 import의 순서대로 적용이 된다. // index.scss @import \"variables.scss\"; // variables.scss $primary: #326dee; $base-padding: 0.75rem; h1 { color: $primary; } 변수를 가져와 계산을 이렇게 할 수 있다. 1. .contact-title { color: $primary; padding: calc($base-padding / 4); } 2. @use \"sass:math\"; .contact-title { color: $primary; padding: math.div($base-padding, 4); } 디버깅하는 방법도 있다. @debug \"hi\"; @debug math.div($base-padding, 4); Loop $colors: ( \"primary\": $primary, \"secondary\": $secondary, \"error\": $error, \"info\": $info, \"blue\": #1919e6, \"yellow\": #e6e619, \"gray\": #808080, ); 위와 같이 colors에 대한 객체를 만들어 놨다. 그리고 아래에 html의 클래스에 넣어주고 싶다. 노가다를 해야할까? &lt;div&gt; &lt;div className=\"text-primary\"&gt;hi&lt;/div&gt; &lt;div className=\"text-secondary\"&gt;hi&lt;/div&gt; &lt;div className=\"text-info\"&gt;hi&lt;/div&gt; &lt;div className=\"text-error\"&gt;hi&lt;/div&gt; &lt;div className=\"text-blue\"&gt;hi&lt;/div&gt; &lt;div className=\"text-yellow\"&gt;hi&lt;/div&gt; &lt;/div&gt; 이럴때 아래의 코드만 입력해주면 바로 완성이다. 리액트에서 변수를 넣을때 $를 넣지만 scss에서는 대신 #을 사용한다. // @each 다음에 오는 첫번째 파라미터는 key값에 해당 두번째 파라미터는 value값에 해당한다. @each $key, $val in $colors { .text-#{$key} { color: $val; } } 만약에 이런 경우에는 어떻게 할 수 있을까? &lt;div&gt; &lt;div className=\"text-primary-light-1\"&gt;hi&lt;/div&gt; &lt;div className=\"text-primary-light-3\"&gt;hi&lt;/div&gt; &lt;div className=\"text-primary-light-5\"&gt;hi&lt;/div&gt; &lt;div className=\"text-secondary-light-1\"&gt;hi&lt;/div&gt; &lt;div className=\"text-secondary-light-3\"&gt;hi&lt;/div&gt; &lt;div className=\"text-secondary-light-5\"&gt;hi&lt;/div&gt; &lt;/div&gt; for문으로 원하는 구간을 만들 수 있다. @each $key, $val in $colors { .text-#{$key} { color: $val; } @for $i from 1 through 9 { .text-#{$key}-light-#{$i} { // someting } } } Conditional for문을 쓴다고?? 그러면 if문도 쓸 수 있지 않을까?? 당연 가능. @if ($val != black and $val != white) { // something } @else { // something } Parent Selectors styled-component와 같이 &amp;를 사용해주면 된다. Mixin Mixin은 스타일 블록을 정의하고, 필요할 때 호출하여 사용할 수 있는 기능이다. @include 키워드를 사용하여 호출합니다. @mixin btn($bg-color: #e2e2e2) { // js 디폴트 파라미터 느낌 text-decoration: none; border: 0; padding: $base-padding; background-color: $bg-color; } @include btn(orange); // 사용할 곳에 추가 @extend 기존 스타일을 상속받으면서 추가적인 스타일을 정의할 때 사용한다. mixin vs extend Mixin은 스타일 블록을 정의하고 호출하여 재사용할 때 사용되고, Extend는 기존 스타일을 다른 선택자에 확장하여 재사용할 때 사용됩니다. Mixin은 새로운 스타일을 생성하는 반면 Extend는 기존 스타일을 공유하여 사용합니다. Function scss에서 제공하는 내장함수들도 많다. @function test($color) { $complement: complement($color); // 주어진 색상의 보색을 반환하는 함수 @return $complement; } color: test(orange); // 사용할 곳에 추가 Making Utility Classes bootstrap 이나 tailwind css를 보면 w-100, p-3과 같이 간단하게 클래스를 만드는 경우를 볼 수 있다. 그걸 만들어 보는 것이다. $utilities: ( \"padding\": ( \"prefix\": \"p\", \"values\": ( \"0\": 0, \"1\": $base-padding, \"2\": $base-padding * 2, \"3\": $base-padding * 3, \"4\": $base-padding * 4, ), ), \"margin\": ( \"prefix\": \"m\", \"values\": ( \"0\": 0, \"1\": $base-margin, \"2\": $base-margin * 2, \"3\": $base-margin * 3, \"4\": $base-margin * 4, ), ), ); 루프를 통해서 만든다. @each $property, $map in $utilities { $prefix: map-get($map, \"prefix\"); // p, m $values: map-get($map, \"values\"); @each $k, $v in $values { .#{$prefix}-#{$k} { #{$property}: #{$v}; } } } Media Queries @content는 mixin 내에 추가적인 스타일을 전달할 수 있다. $breakpoint: ( \"xs\": 0, \"sm\": 480px, \"md\": 720px, \"lg\": 960px, \"xl\": 1200px, ); @mixin xs { @media (min-width: map-get($breakpoint, \"xs\")) { @content; } } @mixin xl { @media (min-width: map-get($breakpoint, \"xl\")) { @content; } } 사용하고 싶은 클래스에 넣으면 된다. @include xl() { width: 500px; } // 참고로 매개변수가 없을 경우에 ()를 생략할 수 있다. 아래는 위와 동일한 코드 @include xl { width: 500px; }"
  },"/til/react-query.html": {
    "title": "React-query",
    "keywords": "til",
    "url": "/til/react-query.html",
    "body": "환경설정 import { QueryClient, QueryClientProvider } from \"react-query\"; const client = new QueryClient({ defaultOptions: {}, }); ReactDOM.createRoot(document.getElementById(\"root\")!).render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client={client}&gt; &lt;App /&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt; ); useQuery const { data, isLoading, error } = useQuery(queryKey, queryFn, options); queryKey 키값에 따라 데이터를 캐싱처리 한다. // 문자열 useQuery('todos', ...) // 배열 useQuery(['todos'], ...) queryFn fetching 함수를 넘기면 된다. useQuery([\"todos\"], () =&gt; somethingfetching() )); useInfiniteQuery continue 도움되는 링크 https://github.com/ssi02014/react-query-tutorial"
  },"/til/next.html": {
    "title": "Next.js",
    "keywords": "til",
    "url": "/til/next.html",
    "body": "Next.js를 사용해야 하는 이유 폴더를 사용하여 페이지를 간단하게 만들 수 있다. 리액트의 경우, react-router-dom을 사용하여 하나하나 만들어줘야 함 자체 api를 생성할 수 있다. SSR과 CSR을 함께 사용 할 수 있다. 최적화가 잘 되어 있다. 코드 분할, 이미지 최적화 등 추가적인 작업을 안해도 되서 편하다. 리액트 팀에서도 next.js 프레임워크를 사용하기를 권장한다. 런타임 에러 (node:29569) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead. (Use `node --trace-deprecation ...` to show where the warning was created) 해결책 nvm을 사용하여, node 18버전으로 다운그레이드 라우팅 app폴더 하위 폴더에 라우팅하고 싶은 페이지명을 폴더명으로 만든다. 그 폴더에는 page.js로 파일을 만든다. 동적라우팅의 경우 [id] 와 같이 대괄호 안에 넣어준다. 그룹화 하고 싶은 경우 (auth) 와 같이 소괄호 안에 넣어준다. 이때 라우팅에서 그룹화 부분은 무시된다. 이미지 이미지 가져오는 방법은 3가지가 있다. 폴더안에 파일의 경로를 넣는 경우 너비와 높이를 지정해야한다. 폴더안에 파일을 import 해서 넣는 경우 너비와 높이를 지정하지 않아도 된다. 외부 경로를 넣는 경우 너비와 높이를 지정해야한다. next.js에서는 기본적으로 외부 이미지를 허용하지 않는다. 사용하려면 해당 이미지의 도메인을 적어주어야 한다. // next.config.js const nextConfig = { images: { domains: [\"example.com\"], }, }; export default nextConfig; blur placeholder=\"blur\" API app폴더 하위 폴더에 api 폴더를 만들고, 라우팅하고 싶은 api를 폴더명으로 만든다. 그 폴더에는 route.js로 파일을 만든다. 동적라우팅의 경우 [id] 와 같이 대괄호 안에 넣어준다. import { NextResponse } from \"next/server\"; export const GET = async (req, res, next) =&gt; { const { id } = res.params; try { await connect(); const post = await Post.findById(id); return new NextResponse(JSON.stringify(post), { status: 200, }); } catch (error) { return new NextResponse(error, { status: 500, }); } }; params 가져오기 Next.js의 API 라우트에서는 요청 객체가 res 매개변수를 통해 전달된다. 따라서 API 라우트에서는 res.params를 사용하여 경로 매개변수를 가져와야 한다. Metadata 각 페이지에 해당 객체를 입력만 해도 간단하게 된다. export const metadata = { title: \"parklego\", description: \"parklego next tutorial\", }; 동적 페이지 경우에는 아래와 같이 생성하면 된다. export const generateMetadata = async ({ params }) =&gt; { const post = await getData(params.id); return { title: post.title, // params someting.. description: post.desc, }; }; Next-auth (Auth.js) OAuth authentication 핸들러 함수를 정의 // pages/api/auth/[...nextauth].js const handler = NextAuth({ providers: [ GoogleProvider({ clientId: process.env.GOOGLE_CLIENT_ID, clientSecret: process.env.GOOGLE_CLIENT_SECRET, }), ], }); export { handler as GET, handler as POST }; .env 파일에서 변수를 추가한다. ... NEXTAUTH_SECRET = 'next-tutorial' NEXTAUTH_URL='https:localhost:3000' ... layout.js 에서 provider로 감싸준다. (provider는 서버 컴포넌트에서 사용못하므로 따로 빼주어야 한다.) \"use client\"; import { SessionProvider } from \"next-auth/react\"; const AuthProvider = ({ children }) =&gt; { return &lt;SessionProvider&gt;{children}&lt;/SessionProvider&gt;; }; export default AuthProvider; 로그인 import { signIn, useSession } from \"next-auth/react\"; ... const session = useSession(); const router = useRouter(); if (session.status === \"loading\") { return &lt;p&gt;loading..&lt;/p&gt; // spinner } if (session.status === \"authenticated\") { router.push(\"/dashboard\"); } ... return ( &lt;button onClick={() =&gt; signIn(\"google\")}&gt;login with google&lt;/button&gt; ) 로그아웃 import { signOut, useSession } from \"next-auth/react\"; ... { session.status === \"authenticated\" &amp;&amp; ( &lt;button onClick={signOut}&gt;logout&lt;/button&gt; ); } protected 페이지 ... if (session.status === \"loading\") { return &lt;p&gt;loading..&lt;/p&gt;; } if (session.status === \"unauthenticated\") { router.push(\"/dashboard/login\"); } if (session.status === \"authenticated\") { // someting .. } 스트리밍 전체 스트리밍 loading.jsx 파일을 만들면 된다. 이 로딩은 같은 폴더 내 다른 페이지에도 영향을 끼친다. 그래서 로딩 스켈레톤을 만들려면 라우트를 그룹화 하여 만들면 된다. 구성요소 스트리밍 import { Suspense } from 'react'; ... return ( &lt;&gt; &lt;div&gt; &lt;Suspense fallback={&lt;CardsSkeleton /&gt;}&gt; &lt;CardWrapper /&gt; &lt;/Suspense&gt; &lt;/div&gt; &lt;div&gt; &lt;Suspense fallback={&lt;RevenueChartSkeleton /&gt;}&gt; &lt;RevenueChart /&gt; &lt;/Suspense&gt; &lt;/div&gt; &lt;/&gt; ) Error error.jsx는 모든 오류를 처리하는 페이지이다. use client 사용 not-found.jsx 페이지가 error.jsx 페이지보다 우선 순위가 높다. import { notFound } from 'next/navigation'; ... if (!invoice) { notFound(); } ... 접근성 향상 기본적으로 eslint-plugin-jsx-a11y라는 플러그인이 포함되어 있다. 이미지태그에서 alt가 빠진 경우나, aria-* 및 role 속성을 잘못 사용하는 경우 등을 경고해준다. \"scripts\": { ... \"lint\": \"next lint\" }, npm run lint Deploy Vercel로 간단하게 프로젝트를 배포할 수 있다. 놀라웠던 점은 Git 저장소를 연결하고 특정 브랜치에 변경 사항이 푸시되면 자동으로 배포를 하더라. 그리고 무중단 배포를 하기때문에 걱정도 덜하다. vercel.com next.js learn next.js tutorial"
  },"/til/network.html": {
    "title": "네트워크",
    "keywords": "til",
    "url": "/til/network.html",
    "body": "REST API란 무엇인가? REST API란 REST를 기반으로 만들어진 API를 의미한다. REST API를 알기 위해 REST부터 알아야 한다. REST REST(Representational State Transfer)의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미. HTTP URI를 통해 자원을 명시하고, HTTP Method (POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD OPERATION을 적용하는 것을 의미한다. 참고 : PUT vs PATCH PUT : 리소스의 모든 것을 업데이트 한다. 덮어씌운다는 느낌. 보내지 않은 데이터는 null로 반환. PATCH : 리소스의 일부를 업데이트 한다. 일부를 수정하는 느낌. 보낸 데이터만 수정됨. 참고 : Get은 왜 body에 데이터를 넣으면 안될까? GET 요청은 서버에서 리소스를 검색하기 위해 설계되었다. HTTP 명세서에서 GET 요청에서 메시지 바디를 사용하지 않는 것은 캐시 및 보안 문제를 일으킬 수 있기 때문이다. REST API REST의 원리를 따르는 API. URL은 동사보다는 명사, 대문자보다는 소문자를 사용한다. 슬래시(/)는 계층 관계를 나타내는데 사용한다. 마지막은 슬래시(/)를 포함하지 않는다. 언더바(_)대신 하이픈(-)을 사용한다. 파일확장자는 URL에 포함하지 않는다. 또한, REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함되어야 한다. 자주 사용되는 상태코드 상태코드 상태 설명 200 OK 서버가 요청을 성공적으로 처리하였다. 201 Created 요청이 처리되어서 새로운 리소스가 생성되었다. 202 Accepted 요청은 접수하였지만, 처리가 완료되지 않았다. 400 Bad Request 잘못된 요청으로 서버가 요청사항을 이해하지 못했다. 401 Unauthorized 지정한 리소스에 대한 액세스 권한이 없다. 403 Forbidden 지정한 리소스에 대한 액세스가 금지되었다. 404 Not Found 지정한 리소스를 찾을 수 없다. 500 Internal Server Error 서버에 에러가 발생하였다. 501 Not Implemented 요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다. 502 Bad Gateway 웹서버가 다른 서버로부터의 잘못된 응답을 받았을 때 발생한다. 참고 : 4xx vs 5xx 4xx : 클라이언트 에러 5xx : 서버 에러 RESTful REST API의 모든 설계 규칙을 올바르게 지킨 시스템을 RESTful하다 라고 한다. REST API란 RESTful API란 REST API 제대로 알고 사용하기 http 상태코드 제대로 이해하는 REST API"
  },"/til/javascript.html": {
    "title": "JavaScript",
    "keywords": "til",
    "url": "/til/javascript.html",
    "body": "호이스팅 호이스팅(Hoisting)이란, var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다. 자바스크립트는 ES6에서 도입된 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅한다. 아래는 가장 대표적인 예시이다. console.log(a); // undefined var a = 1; 선언하지 않은 것인데도 에러가 발생하지 않는다. helloWorld(); // Hello World! function helloWorld() { console.log(\"Hello World!\"); } 선언을 하지도 않았는데 함수에 접근할 수 있다. 왜 그런 것일까?? 자바스크립트에서의 변수는 선언 단계 &gt; 초기화 단계&gt; 할당 단계에 걸쳐 생성되는데 컴파일 단계에서 함수와 변수 선언이 스캔된다. 스캔 된 모든 함수, 변수 선언은 Lexical Environment라고 불리는 자바스크립트 데이터 구조 내 메모리에 추가된다. (이때가 스코프의 선두로 옮긴 것처럼 동작하게끔 보이는 것이고 접근 가능케 되는 것이다. ) console.log(a); // ReferenceError const a = 3; 가끔 다른 블로그를 보면 let 과 const가 호이스팅이 안된다고 말하는 사람들이 있는데 그것은 잘못 된 것이다. var는 선언 단계와 초기화 단계가 한번에 이루어진다. 그래서 undefined가 찍히는 것이다. 반면,let과 const는 호이스팅이 되어 선언단계까지는 왔으나 초기화 단계가 없어서 에러를 뱉는 것이다. 위의 주석처리를 보면 이제 이해가 갈 것이다. 이때를 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠진다고 생각하면 된다. 클로저 클로저를 쉽게 이해하기 위해서는 배경지식이 필요하다. 먼저, 실행 컨텍스트를 알아야한다. 함수는 호출 될 때 함수의 실행 컨텍스트가 생성됐다가 실행이 끝나면 실행 컨텍스트가 종료된다. 이때 실행 컨텍스트의 lexical environment에는 함수의 지역 변수의 정보와 이 함수의 상위 스코프의 대한 정보가 들어있다. (scope chain) 클로저란? 함수가 생성 될 때 주변 환경의 상태를 기억하여(lexical environment) 나중에 호출될 때 그 값에 접근할 수 있는 것을 말한다. 예제를 보자면, function makeCounter() { let count = 0; function inner() { count++; return count; } return inner; } let counter = makeCounter(); console.log(counter()); // 1 console.log(counter()); // 2 console.log(counter()); // 3 이 코드에서 makeCounter 함수는 inner 함수를 정의하고, 이를 반환한다. inner 함수는 외부 함수인 makeCounter 함수 내에 정의되어 있지만, 외부 변수인 count에 접근할 수 있다. 이렇게 반환된 inner 함수가 클로저이다. 이제 counter 변수에는 inner 함수가 할당되어 있고, 이를 호출할 때마다 count 변수가 증가한다. 정리 클로저 (Closure) 함수는 외부 함수 밖에서 내부 함수가 호출 되더라도 외부 함수의 지역 변수에 접근할 수 있다 그 이유는 자신이 생성될 때의 환경 즉, Lexical Environment을 기억하고 있기 때문이다. 이벤트 루프 JavaScript는 단일 스레드 프로그래밍 언어이다. 즉, 단일 호출 스택이 있음을 의미한다. 그러므로 한 번에 한 가지 일만 할 수 있다. JavaScript는 크게 Memory Heap과 Call Stack으로 이루어져 있다. Memory Heap : 메모리 할당이 일어나는 장소 Call Stack : 코드가 실행될 경우 하나씩 stack의 형태로 쌓이는 장소 Call Stack에서 실행된 비동기 함수는 Web API에서 처리를 하게 되고, 그동안에 Call Stack은 나머지 동기 함수들을 처리하게 된다. Web API는 브라우저(Chrome)에서 멀티 스레드로 구현되어 있다. 그래서 브라우저는 비동기 작업에 대해 메인 스레드를 차단하지 않고, 다른 스레드를 사용하여 동시에 처리할수 있는 것이다. (DOM, AJAX, setTimeout 등) 작업이 완료된 비동기 함수들을 Callback Queue로 넘겨주게 된다. Event Loop는 Call Stack과 Callback Queue를 상태를 계속 감시하며 Call Stack에 함수들이 존재하지 않는다면 Callback Queue에 있는 비동기 함수들을 Call Stack에 밀어 넣게 된다. 그 후 Call Stack에서 비동기 함수를 실행시키게 된다. 참고 : https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC 참고 : https://blog.toktokhan.dev/t-767eb0fa38f3 Nullish coalescing 값이 null 이나 undefined 인지 체크 const displayName = name ?? \"익명\"; 메서드 for in 객체 순환 let object = { a: 1, b: 2, c: 3, }; // key 값 접근 for (let key in object) { console.log(key); // a,b,c } // value 값 접근 for (let key in object) { console.log(object[key]); // 1,2,3 } for of 배열 순환 let array = [1, 2, 3]; for (let value of array) { console.log(value); // 1,2,3 } forEach 배열 순환 return 값 X let array = [1, 2, 3]; array.forEach((value) =&gt; console.log(value)); // 1,2,3 map 배열 순환 return 값이 변형된 값(return값)들의 모음 let array = [1, 2, 3]; let double = array.map((item) =&gt; { return item * 2; }); console.log(double); // [1,2,3] filter 배열 순환 return 값이 true인 값들의 모음 let array = [1, 2, 3, 4]; let odd = array.filter((item) =&gt; { return item % 2; }); console.log(odd); // [1,3] reduce 배열 순환 callback함수의 실행 값을 누적하여 하나의 결과값을 반환 초기값 설정 필요 (설정하지 않으면 배열 0번째 요소의 값) const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; const sum = numbers.reduce((acc, curr) =&gt; { return acc + curr; }, 0); console.log(sum); // 55 split 문자열을 구분자 기준으로 나누어 배열로 변환 const str = \"apple banana orange\"; const arr = str.split(\" \"); console.log(arr); // [ 'apple', 'banana', 'orange' ] join 배열의 모든 요소를 쉼표나 지정된 구분 문자열로 구분하여 연결한 새 문자열을 만들어 반환 const elements = [\"Fire\", \"Air\", \"Water\"]; console.log(elements.join()); // Fire,Air,Water console.log(elements.join(\"\")); // FireAirWater console.log(elements.join(\"-\")); // Fire-Air-Water toSorted 요소들을 오름차순으로 정렬한 새로운 배열을 반환 toReversed 요소들을 내림차순으로 정렬한 새로운 배열을 반환"
  },"/til/git-github.html": {
    "title": "Git/Github",
    "keywords": "til",
    "url": "/til/git-github.html",
    "body": "git config 설정 확인 및 변경하기 git config에 대한 리스트를 보고자 하는 경우에는 아래와 같은 커맨드를 입력한다. git config --list git config 설정하는 방법 중에 가장 많이 쓰이는 것이 이름과 이메일 변경이다. 이 경우에는 아래와 같이 수정한다. git config --global user.name \"고양이\" git config --global user.email \"hbd9425@gmail.com\" 참고로 한글이 깨지는 경우에는 아래와 같이 입력한다. git config --global core.quotepath false Jekyll GitHub Pages 배포 및 테마적용 사전 준비 Ruby 설치 Jekyll 설치 테마 선택 jamstackthemes.dev http://jekyllthemes.org/ 코드블럭 선택 https://spsarolkar.github.io/rouge-theme-preview/ 배포 및 테마 적용하기 github repository 생성 repository명은 github 아이디.github.io로 생성할 것 repository는 public 으로 할 것 ex) parklego.github.io bundle 명령어 실행 bundle install bundle exec jekyll serve 블로그 설정 _conif.yml 파일에서 제목이나 이름 등을 변경 Gemfile 플러그인 설치하는 곳 siteamp 파일 생성 Gemfile 파일에서 아래 코드 추가 gem 'jekyll-sitemap' _config.yml 파일에서 아래 코드 추가 plugins: -jekyll - sitemap; Terminal 에서 bundle 입력. Terminal 에서 아래 명령어 입력 gem install jekyll-sitemap 지킬 서버 재실행 bundle exec jekyll serve commit 깔끔하게 남기기 main branch에 다른 branch를 병합할 때, 쓰이는 방법은 두 가지이다. 하나는 merge, 그리고 다른 하나는 rebase이다. 이 둘의 가장 큰 차이는 깔끔함에 있다. merge를 사용하면 모든 commit을 남기게 되지만, rebase를 사용하면 필요없는 commit을 생략시킬 수 있다. 예제를 통해 알아보기 첫 작업을 완료 후 아래와 같이 commit을 남겼다. git add . git commit -m '테스트 추가' 두 번째 작업을 완료 후 아래와 같이 commit을 남겼다. git add . git commit -m '테스트 추가 2' 세 번째 작업을 완료 후 아래와 같이 commit을 남겼다. 그리고 해당 작업이 끝나서 push를 해야하는 상황이다. git add . git commit -m '테스트 추가 3' commit을 정리하기 전에 git log를 통해 몇 개의 commit을 정리할지 파악한다. 여러 날에 걸쳐서 작업된 경우에는 몇 개의 commit을 했는지 파악하기 힘들기 때문이다. git log push 하기 전에 rebase로 불필요한 commit을 정리할 수 있다. git rebase -i @~3 // -i는 --interactive 옵션이고 대화형으로 진행한다는 뜻이다. // @~3은 root(최근)를 기준으로 3개의 commit을 rebase하겠다는 뜻이다. // HEAD~3과 같은 뜻이다. rebase 편집 화면. i를 눌러 수정모드에서 7번 과정처럼 변경한다. pick 74cd541 test 추가 pick a6d2a9f test 추가 2 pick e5e93ab test 추가 3 # Rebase 83ffc92..e5e93ab onto 83ffc92 # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 편집을 하고 :wq로 vi를 빠져나온다. pick 74cd541 test 추가 s a6d2a9f test 추가 2 // pick -&gt; s (squash) s e5e93ab test 추가 3 // pick -&gt; s (squash) # Rebase 83ffc92..e5e93ab onto 83ffc92 # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 그 다음 vi로 commit을 수정할 수 있게 된다. # This is a combination of 3 commits. # This is the 1st commit message: test 추가 # This is the commit message #2: test 추가 2 # This is the commit message #3: test 추가 3 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. ... 최종 commit 메세지를 수정하는 것이므로 그냥 다 삭제하고, commit 메세지를 작성한다. → shift + v로 블럭설정 모드로 들어간 뒤 shift + 커서로 모두 지정하고, dd를 눌러 삭제를 한다. rebase 완료 Successfully rebased and updated refs/heads/main. 간단하게 git switch main git merge --squash 브랜치명 git commit -m '메세지' ssh key 생성 Git 서버들은 SSH 공개키로 인증을 한다. SSH 공개키 확인 $ cd ~/.shh $ ls id_dsa 혹은 id_dsa.pub 파일이 있으면 공개키가 생성된 적이 있는 것이다. 없다면 생성을 하자. pub확장자를 가진 파일은 공개키이므로 공개되어도 괜찮지만, 다른 파일은 개인키이므로 각별히 주의하자. SSH 공개키 생성 $ ssh-keygen 생성할 때, 묻는 질문이 있는데 그냥 엔터를 계속 눌러서 진행하자. 그러면 생성 될 것이다. 위의 커맨드를 이용해서 잘 생성되었는지 확인하고, 넘어가자. Git에 SSH key 등록 $ cat id_rsa.pub 위의 커맨드를 이용해서 값을 복사한다. 그 이후, github setting으로 들어간다. ssh and GPG keys라는 탭으로 들어가서, new ssh key 버튼을 눌러 복사한 값을 넣어주면 끝."
  },"/til/db.html": {
    "title": "DB",
    "keywords": "til",
    "url": "/til/db.html",
    "body": "MongoDB OverwriteModelError 런타임 에러 ⨯ OverwriteModelError: Cannot overwrite Users model once compiled. 해결책 ... const User = mongoose.models.Users || mongoose.model(\"Users\", userSchema); module.exports = User;"
  },"/til/css.html": {
    "title": "CSS",
    "keywords": "til",
    "url": "/til/css.html",
    "body": "텍스트에 자연스럽게 gradient 넣기 백그라운드 영역에 먼저 그라디언트를 넣어준다. background: linear-gradient(to bottom, #194c33, #bbb); // 예시 아래와 같이 속성을 넣어준다. -webkit-background-clip: text; // 텍스트 내부에만 배경 이미지를 적용하도록 지정 -webkit-text-fill-color: transparent; // 글씨 투명하게 지정 top,right, bottom, left 한번에 처리하기 padding과 margin과 같이 한 줄로 표현이 가능하다. // As-is top: 0; right: 0; bottom: 0; left: 0; // To-be inset: 0;"
  },"/til/bundler.html": {
    "title": "Bundler",
    "keywords": "til",
    "url": "/til/bundler.html",
    "body": "esbuild 웹팩보다 100배 빠르다. build file //build.js import esbuild from \"esbuild\"; import pkg from \"./package.json\" assert { type: \"json\" }; // 라이브러리를 번들에 포함하지 않고 외부에 유지함으로써 번들 크기를 최적화 const external = Object.keys({ ...pkg.devDependencies, ...pkg.peerDependencies, }); const baseConfig = { entryPoints: [\"src/index.ts\"], bundle: true, minify: true, sourcemap: true, outdir: \"dist\", target: \"es2019\", external, }; // 디버깅, 개발시간 단축을 위해 프로덕션환경에서만 활성화 하기 if (process.env.NODE_ENV !== \"production\") { baseConfig.minify = false; } // mjs, cjs 병렬로 처리하기 // Node.js와 브라우저 환경 모두에서 호환되는 라이브러리를 개발할 때, 일반적으로 CommonJS와 ECMAScript 모듈 형식을 모두 지원하는 것이 좋다 Promise.all([ esbuild.build({ ...baseConfig, format: \"esm\", }), esbuild.build({ ...baseConfig, format: \"cjs\", outExtension: { \".js\": \".cjs\", }, }), ]).catch(() =&gt; { console.error(\"Build failed\"); process.exit(1); }); typescript tsconfig.json에 필요한 옵션을 설정한다. { \"compilerOptions\": { \"outDir\": \"./dist\", \"target\": \"ESNext\", \"module\": \"ESNext\", \"lib\": [\"ESNext\", \"DOM\"], \"declaration\": true, \"strict\": true, \"moduleResolution\": \"Node\", \"jsx\": \"react-jsx\", \"removeComments\": true } } script package.json 파일에서 node로 빌드 파일을 실행시켜 주면 된다. \"scripts\": { \"build\": \"npm run build:ts &amp;&amp; npm run build:js\", \"build:js\": \"node build.js\", \"build:ts\": \"tsc --emitDeclarationOnly\" }"
  },"/til/architecture.html": {
    "title": "Architecture",
    "keywords": "til",
    "url": "/til/architecture.html",
    "body": "모놀리식 vs 멀티레포 vs 모노레포 모놀리식 아키텍쳐 애플리케이션의 모든 구성 요소가 한 프로젝트에 통합되어 있는 형태를 말한다. 장점: 단일 애플리케이션으로 구성되어 있으므로 배포 프로세스가 단순 모든 코드가 하나의 코드베이스에 있으므로 전체 시스템의 상호작용을 이해하기 쉽다. 코드를 빠르게 수정하고 테스트할 수 있다. 초기에는 적은 코드베이스로 빠르게 시작할 수 있다. 단점: 큰 규모의 애플리케이션에서는 모놀리식 아키텍처가 더 이상 확장하기 어려울 수 있다. 작은 변경 사항을 배포할 때 전체 애플리케이션을 다시 배포해야 할 수 있다. 코드베이스가 커질수록 기술적 부채가 쌓이는 경향이 있습니다. 단위 테스트와 통합 테스트를 관리하기 어려울 수 있다. 언제 사용? 작은 및 중소규모 애플리케이션 또는 프로토타입 개발에 적합합니다. 초기에 빠르게 개발하고 배포하려는 경우에 사용할 수 있습니다. 개발 및 배포 프로세스를 단순화하고자 하는 경우에 적합합니다. 마이크로서비스 아키텍쳐(MSA) 마이크로서비스 아키텍쳐는, 모놀리식 아키텍쳐의 단점을 보완하기 위해 만들어진 패턴으로, 최소한의 공통 모듈만을 두고, 각각의 서비스를 다른 저장소로 관리한다. 리포지토리를 관리하는 방법은 시스템의 각 모듈을 개별 리포지토리에서 관리할 것인지, 하나의 리포지토리에서 관리할 것인지에 따라서 달라진다. 이때 나눠서 관리하는 것을 멀티리포, 하나로 관리하는 것을 모노리포라 정의한다. 멀티레포 멀티레포의 장점 프로젝트의 자율성이 높다. 프로젝트별로 빌드가 가능하다. 프로젝트별 독립적이기에 유연하다. 멀티레포의 단점 프로젝트를 새로 만들 때마다 개발 환경, 배포 환경을 구성해야 한다. 코드 중복이 생긴다. 프로젝트 개수가 늘어나면 점점 관리가 어려워질 수 있다. 언제사용? 각 서비스가 독립적으로 관리되어야 할 때 사용합니다. 팀 간 협업이 중요한 프로젝트에서 사용합니다. 기술 다양성이 필요한 경우 사용합니다. 모노레포 모노레포의 장점 프로젝트 공통 항목을 처리하기 쉽다. 새 프로젝트를 만들 때 생성 비용이 적다. 프로젝트의 패키지 관리, 설정 등 통합해서 할 수 있다. (DX) 멀티레포보다 의존성 관리가 우수하다. 모노레포의 단점 모든 서비스가 단일 레포지토리에 있기 때문에 서비스 간의 의존성 관리가 복잡할 수 있다. 여러 팀이 단일 레포지토리에서 작업할 때 충돌이 발생할 수 있다. 모든 서비스가 단일 레포지토리에 있으므로 레포지토리 크기가 커질 수 있다. 언제사용? 프로젝트 전체의 일관성과 코드 공유가 중요한 경우 사용합니다. 통합 및 테스트가 중요한 프로젝트에서 사용합니다. 배포 프로세스를 단순화하고자 할 때 사용합니다."
  },"/til/DesignSystem.html": {
    "title": "Design System",
    "keywords": "til",
    "url": "/til/DesignSystem.html",
    "body": "Introduction 디자인 시스템의 정의 “디자인 시스템은 다양한 페이지와 채널을 걸쳐 공통의 언어와 시각적 일관성을 만들고 반복되는 작업을 줄임으로써, 규모에 맞게 디자인을 관리하기 위한 표준 집합이다.” 디자인 시스템의 목적 제품을 처음 만들 때는 초기에 세운 규칙들이 잘 이행되고 반영됩니다. 하지만 시간이 지날수록 이런 규칙들이 어긋나고 점차 사라지는 등 불협화음이 필연적으로 발생합니다. 새로운 프로젝트 구성원과 팀이 관여하고, 다양한 플랫폼에 걸쳐 프로젝트가 확장되면 이러한 현상이 가속되며 결국 제품의 사용자 경험에 큰 영향을 미칠 수 있습니다. 이러한 혼란을 방지하고 질서를 세우는 역할을 하는 것이 디자인 시스템입니다. 디자인 시스템은 어떤 제품을 만들 때 표준 규칙을 세우고 이에 따라 작업을 효율적이고, 일관되며, 나아가 확장할 수 있도록 합니다. Structure 디자인 시스템의 구조 원칙 테마 혹은 파운데이션 컴포넌트 패턴 도구 및 유틸리티 문서화 가이드라인 프로세스 및 워크 플로우 Foundation 파운데이션은 일관된 레이아웃과 그에 따른 사용자 경험을 만드는 데 필수적인 시각적 요소입니다. color spacing typography iconography … Components 컴포넌트는 파운데이션을 기반으로 레이아웃을 구성하는 코드. 디자인시스템의 재사용 가능한 구성요소입니다. Design language 디자인 언어를 잘 설정 및 통일 하여야 합니다. 가장 중요한 부분입니다. 예를 들어, A 상황일 때 black_light를 사용해야 한다면 black_light의 raw color인 black_200를 사용해주세요! 라고 구체적으로 인스턴스화가 되어야 합니다. Bar의 이름을 iOS에서는 “Navigation Bar”, Android에서는 “App Bar”라고 합니다. 헷갈리지 않게 네이밍을 통일할 필요가 있습니다. 도움될 만한 사이트 : https://spectrum.adobe.com/ 도움될 만한 사이트 : https://gds.gmarket.co.kr/ 참고 : https://devocean.sk.com/blog/techBoardDetail.do?ID=163710 참고 : https://brunch.co.kr/@monodream/6 참고 : https://gsretail.tistory.com/20"
  }}
