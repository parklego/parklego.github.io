{"/pages/about": {
    "title": "About",
    "keywords": "self",
    "url": "/pages/about",
    "body": "안녕하세요, 프론트엔드 개발자 박레고입니다. 반갑습니다! 😊 이곳은 제가 개발과 관련된 내용을 간단히 기록하는 곳입니다. 주로 TIL에 대한 내용입니다. 그리고 사용해본 라이브러리 중 엄청 좋았다고 생각드는 라이브러리들도 엄선해보았습니다. 나의 과거 흔적들 티스토리 벨로그 나의 인기글ㅎㅎ 이때 첫 포스터였는데 16만명이 방문한 글이라 뜻깊은 포스터 var, let, const 차이점 그나마 많이 찾아주는 포스터 스크롤 해도 배경이미지는 고정하기 개발하면서 보면 좋은 자료들 링크 모음 stateofjs 프로그래머스리포트 카카오FE기술블로그 우아한기술블로그 toastUI"
  },"/pages/library": {
    "title": "라이브러리 추천",
    "keywords": "library",
    "url": "/pages/library",
    "body": "use-debounce hook 형태로 간단하게 디바운스 기능을 구현하는 라이브러리 공식문서 Tui-editor 편집기를 사용하면 텍스트 또는 WYSIWYG를 사용하여 Markdown 문서를 편집할 수 있으며 구문 강조, 스크롤 동기화, 실시간 미리 보기 및 차트 기능이 함께 제공하는 라이브러리 공식문서 Frogress 1% 이하의 수를 표현하거나 그라디언트를 넣을 경우 자연스럽게 보이게 하기 위한 progress bar 라이브러리 공식문서 SweetAlert2 아이콘, 애니메이션 등 예쁜 alert 라이브러리 공식문서 Hamburger-react 햄버거 버튼 라이브러리 공식문서 React Spinners spinners and loader 라이브러리 공식문서 React-toastify 간단한 toast 라이브러리 공식문서 React-hot-toast 간단한 toast 라이브러리2 공식문서 React-icons 간단한 icons 라이브러리 공식문서"
  },"/til/think.html": {
    "title": "개발일지",
    "keywords": "til",
    "url": "/til/think.html",
    "body": "라이트/다크 모드 최근에 create-react-app을 더 이상 사용하지 않는다는 소식을 들었다. 그래서 다음에는 vite를 이용해보고자 했는데 드디어 사용해보게 되었다. 새로 해보는 만큼 라이브러리도 써보지 않은 다양한 것을 사용해보고 싶었다. 그래서 shadcn도 설정하였다. 설정하는 단계가 조금 귀찮다. 그리고 문서가 자세하지가 않다. 그렇지만 이쁘다. 그리고 상태관리로는 최근에 가장 가파른 상승세를 타고 있는 zustand를 사용해보기로 했다. 처음에 해보고 싶었던 것은 라이트/다크모드를 설정해보는 기능을 구현해보고 싶었다. localstorage를 이용해서 구현할 것이고, styled-component의 themeProvider로 구현하고자 하였다. 그런데 zustand에 localstorage가 있었다. 그래서 persist middleware와 함께 이용하기로 했다. shadcn의 switch 컴포넌트를 이용해 토글기능으로 다크모드를 on/off 하였다. 그러다 ux측면도 고려해보게 되었다. 내가 주로 검색하는데 사용하는 phind와 shadcn의 다크모드 기능을 살펴보았다. phind의 경우에는 처음에 os의 테마를 바탕으로 사이트를 변경해준다. 이때 localstorage에는 테마의 키-벨류가 없다. 그리고 유저가 테마를 건드리면 그때 키-벨류값이 생기고 이에따라 테마가 변경된다. shadcn의 경우 처음부터 라이트/다크/시스템 이렇게 선택할 수 있게 설정이 되어 있다. 다크모드 구현이 단순한 기능인줄 알았는데 생각보다 다양한 방법도 있다는 것을 알았다. UX도 생각보다 빠르게 발전하고 있구나 싶었다. os 테마변경에 따른 실시간 변경을 위해 커스텀훅을 만들어서 구현하였다. 인터렉티브 프론트엔드 개발자라면 인터렉티브한 웹사이트를 보게되면 이벤트를 발생시켜보면서 어떻게 구현했나? 궁금하고 신기해 한다. 간혹 채용 공고의 우대사항에서도 three.js 사용해본 경험이라던지 R3F에 대한 내용이 더러 있다. 언젠가는 애플과 같은 (스크롤을 감지하여 배경화면을 랜더링) 이쁘고 깔끔한 개발을 해보고 싶다는 생각이 있었는데 최근에 다양한 기술로 가볍게 만들어본 프로젝트의 배경이 생각이 났다. 그래서 three.js를 찍먹이나 해보자는 생각으로 시도를 해보았다. 아래는 우와! 소리가 절로 나올만한 사이트들이다. 드래그를 하면 마우스를 추적하여 꽃이 피어오른다. Nomadic Tribe — makemepulse 30종류의 동물들이 조각형태로 변환되는 것을 보여준다. In Pieces – 30 Species, 30 Pieces. 1 Fragmented Survival. 그 외에 해외에서 다양한 인터렉티브한 사이트들을 한눈에 볼 수 있는 사이트이다. UI도 깔끔하고, 다양한 아이디어들을 볼 수 있어서 좋은 것 같다. CSS Design Awards - Website Awards - Best Web Design Inspiration - CSS Awards https://thefwa.com/awards/page/1/ 찍먹이기에 나는 모델이 마우스 커서를 주시하여 움직이는 정도로만 구현해보고자 했다. 어느정도의 개념적인 부분은 아래에 블로그를 참고 하였고, 내가 구현한 코드를 설명하자면 ... const sensitivity = 1000; useEffect(() =&gt; { const handleMouseMove = (event: MouseEvent) =&gt; { setMousePosition({ x: event.clientY / sensitivity, y: event.clientX / sensitivity, }); }; window.addEventListener(\"mousemove\", handleMouseMove); return () =&gt; { window.removeEventListener(\"mousemove\", handleMouseMove); }; }, []); useFrame((state, delta) =&gt; { meshRef.current.rotation.x = mousePosition.x; meshRef.current.rotation.y = mousePosition.y - 1000; }); ... @react-three/fiber에서 제공하는 useFrame을 사용하여 매 프레임마다 rotation되게 하면 모델을 움직일 수 있게 할 수 있을 것 같았다. 그러기 위해서 마우스의 움직임을 추적해야하는데 이를 위해 handleMouseMove 라는 함수를 만들어 주었다. (useFrame은 애니메이션을 처리하거나 실시간으로 변화하는 값을 관리할 때 주로 사용한다.) 마우스를 좌,우(x축)로 움직였을 때 모델이 위아래로 움직였고 상,하로 움직였을 때 모델이 좌우로 움직였다. 그래서 포지션을 반대로 해주면 될 것 같았다. 그러나 너무 빠르게 움직여서 미친듯이 움직였다. 그래서 민감도를 주기 위하여 그 값을 큰 값으로 나누어서 값의 크기를 줄였더니 원하는대로 움직였다. 하지만 내가 개발한 페이지에서 모델은 오른쪽에 배치를 했기 때문에 가용범위를 고려하여 실제 회전을 할 때에 y값에 -값을 추가해보면서 자연스러운 값을 찾았다. Canvas 위에 Mesh라는 Object를 얹는다는 느낌으로 이해하면 된다. 3D 모델은 아래의 사이트에서 찾아서 불러왔다. https://sketchfab.com/feed"
  },"/til/web-Accessibility.html": {
    "title": "웹 접근성",
    "keywords": "til",
    "url": "/til/web-Accessibility.html",
    "body": "웹 접근성(a11y)는 정보에 동등하게 접근하고 이해 할 수 있도록 보장하기 위해 중요하다. wai-aria란? aria 사용방법 리액트 jsx에서 wai-aria를 지원한다. aria-\\* 과 같은 어트리뷰트는 kebab-case로 작성해야한다. role 태그의 역할을 알려주는 속성 정해진 값만 사용하여야 한다. aria-label 스크린 리더기에 전달할 내용을 알려주는 속성 예를들어, 어코디언이 있으면 펼치기와 같이 aria-label를 통해 알려줄 수 있다. 주의할 점은 시멘틱 태그이거나, role 속성 값이 상호작용(interactive)을 하는 값일 때 aria-label을 붙일 수 있다는 것이다. aria-label과 role을 쓰기 위한 규칙 tabindex 0 : 상호작용 가능한 요소 처럼 포커싱이 된다. -1 : 포커싱에서 제외 된다. 양수 : 강제로 순서를 정한다. 그 이후에 브라우저의 포커싱 순서대로 잡힌다. 무조건 피해야함. img alt 이미지가 나오지 않을 때, 이미지에 대한 설명 aria-required true인 경우, 스크린 리더기에 필수요소임을 알려주는 속성"
  },"/til/next.html": {
    "title": "Next.js",
    "keywords": "til",
    "url": "/til/next.html",
    "body": "Next.js를 사용해야 하는 이유 폴더를 사용하여 페이지를 간단하게 만들 수 있다. 리액트의 경우, react-router-dom을 사용하여 하나하나 만들어줘야 함 자체 api를 생성할 수 있다. SSR과 CSR을 함께 사용 할 수 있다. 최적화가 잘 되어 있다. 코드 분할, 이미지 최적화 등 추가적인 작업을 안해도 되서 편하다. 리액트 팀에서도 next.js 프레임워크를 사용하기를 권장한다. 런타임 에러 (node:29569) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead. (Use `node --trace-deprecation ...` to show where the warning was created) 해결책 nvm을 사용하여, node 18버전으로 다운그레이드 라우팅 app폴더 하위 폴더에 라우팅하고 싶은 페이지명을 폴더명으로 만든다. 그 폴더에는 page.js로 파일을 만든다. 동적라우팅의 경우 [id] 와 같이 대괄호 안에 넣어준다. 그룹화 하고 싶은 경우 (auth) 와 같이 소괄호 안에 넣어준다. 이때 라우팅에서 그룹화 부분은 무시된다. 이미지 이미지 가져오는 방법은 3가지가 있다. 폴더안에 파일의 경로를 넣는 경우 너비와 높이를 지정해야한다. 폴더안에 파일을 import 해서 넣는 경우 너비와 높이를 지정하지 않아도 된다. 외부 경로를 넣는 경우 너비와 높이를 지정해야한다. next.js에서는 기본적으로 외부 이미지를 허용하지 않는다. 사용하려면 해당 이미지의 도메인을 적어주어야 한다. // next.config.js const nextConfig = { images: { domains: [\"example.com\"], }, }; export default nextConfig; API app폴더 하위 폴더에 api 폴더를 만들고, 라우팅하고 싶은 api를 폴더명으로 만든다. 그 폴더에는 route.js로 파일을 만든다. 동적라우팅의 경우 [id] 와 같이 대괄호 안에 넣어준다. import { NextResponse } from \"next/server\"; export const GET = async (req, res, next) =&gt; { const { id } = res.params; try { await connect(); const post = await Post.findById(id); return new NextResponse(JSON.stringify(post), { status: 200, }); } catch (error) { return new NextResponse(error, { status: 500, }); } }; params 가져오기 Next.js의 API 라우트에서는 요청 객체가 res 매개변수를 통해 전달된다. 따라서 API 라우트에서는 res.params를 사용하여 경로 매개변수를 가져와야 한다. Metadata 각 페이지에 해당 객체를 입력만 해도 간단하게 된다. export const metadata = { title: \"parklego\", description: \"parklego next tutorial\", }; 동적 페이지 경우에는 아래와 같이 생성하면 된다. export const generateMetadata = async ({ params }) =&gt; { const post = await getData(params.id); return { title: post.title, // params someting.. description: post.desc, }; }; Next-auth (Auth.js) OAuth authentication 핸들러 함수를 정의 // pages/api/auth/[...nextauth].js const handler = NextAuth({ providers: [ GoogleProvider({ clientId: process.env.GOOGLE_CLIENT_ID, clientSecret: process.env.GOOGLE_CLIENT_SECRET, }), ], }); export { handler as GET, handler as POST }; .env 파일에서 변수를 추가한다. ... NEXTAUTH_SECRET = 'next-tutorial' NEXTAUTH_URL='https:localhost:3000' ... layout.js 에서 provider로 감싸준다. (provider는 서버 컴포넌트에서 사용못하므로 따로 빼주어야 한다.) \"use client\"; import { SessionProvider } from \"next-auth/react\"; const AuthProvider = ({ children }) =&gt; { return &lt;SessionProvider&gt;{children}&lt;/SessionProvider&gt;; }; export default AuthProvider; 로그인 import { signIn, useSession } from \"next-auth/react\"; ... const session = useSession(); const router = useRouter(); if (session.status === \"loading\") { return &lt;p&gt;loading..&lt;/p&gt; // spinner } if (session.status === \"authenticated\") { router.push(\"/dashboard\"); } ... return ( &lt;button onClick={() =&gt; signIn(\"google\")}&gt;login with google&lt;/button&gt; ) 로그아웃 import { signOut, useSession } from \"next-auth/react\"; ... { session.status === \"authenticated\" &amp;&amp; ( &lt;button onClick={signOut}&gt;logout&lt;/button&gt; ); } protected 페이지 ... if (session.status === \"loading\") { return &lt;p&gt;loading..&lt;/p&gt;; } if (session.status === \"unauthenticated\") { router.push(\"/dashboard/login\"); } if (session.status === \"authenticated\") { // someting .. } 스트리밍 전체 스트리밍 loading.jsx 파일을 만들면 된다. 이 로딩은 같은 폴더 내 다른 페이지에도 영향을 끼친다. 그래서 로딩 스켈레톤을 만들려면 라우트를 그룹화 하여 만들면 된다. 구성요소 스트리밍 import { Suspense } from 'react'; ... return ( &lt;&gt; &lt;div&gt; &lt;Suspense fallback={&lt;CardsSkeleton /&gt;}&gt; &lt;CardWrapper /&gt; &lt;/Suspense&gt; &lt;/div&gt; &lt;div&gt; &lt;Suspense fallback={&lt;RevenueChartSkeleton /&gt;}&gt; &lt;RevenueChart /&gt; &lt;/Suspense&gt; &lt;/div&gt; &lt;/&gt; ) Error error.jsx는 모든 오류를 처리하는 페이지이다. use client 사용 not-found.jsx 페이지가 error.jsx 페이지보다 우선 순위가 높다. import { notFound } from 'next/navigation'; ... if (!invoice) { notFound(); } ... 접근성 향상 기본적으로 eslint-plugin-jsx-a11y라는 플러그인이 포함되어 있다. 이미지태그에서 alt가 빠진 경우나, aria-* 및 role 속성을 잘못 사용하는 경우 등을 경고해준다. \"scripts\": { ... \"lint\": \"next lint\" }, npm run lint Deploy Vercel로 간단하게 프로젝트를 배포할 수 있다. 놀라웠던 점은 Git 저장소를 연결하고 특정 브랜치에 변경 사항이 푸시되면 자동으로 배포를 하더라. 그리고 무중단 배포를 하기때문에 걱정도 덜하다. vercel.com next.js learn next.js tutorial"
  },"/til/network.html": {
    "title": "네트워크",
    "keywords": "til",
    "url": "/til/network.html",
    "body": "REST API란 무엇인가? REST API란 REST를 기반으로 만들어진 API를 의미한다. REST API를 알기 위해 REST부터 알아야 한다. REST REST(Representational State Transfer)의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미. HTTP URI를 통해 자원을 명시하고, HTTP Method (POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD OPERATION을 적용하는 것을 의미한다. 참고 : PUT vs PATCH PUT : 리소스의 모든 것을 업데이트 한다. 덮어씌운다는 느낌. 보내지 않은 데이터는 null로 반환. PATCH : 리소스의 일부를 업데이트 한다. 일부를 수정하는 느낌. 보낸 데이터만 수정됨. 참고 : Get은 왜 body에 데이터를 넣으면 안될까? GET 요청은 서버에서 리소스를 검색하기 위해 설계되었다. HTTP 명세서에서 GET 요청에서 메시지 바디를 사용하지 않는 것은 캐시 및 보안 문제를 일으킬 수 있기 때문이다. REST API REST의 원리를 따르는 API. URL은 동사보다는 명사, 대문자보다는 소문자를 사용한다. 슬래시(/)는 계층 관계를 나타내는데 사용한다. 마지막은 슬래시(/)를 포함하지 않는다. 언더바(_)대신 하이픈(-)을 사용한다. 파일확장자는 URL에 포함하지 않는다. 또한, REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함되어야 한다. 자주 사용되는 상태코드 상태코드 상태 설명 200 OK 서버가 요청을 성공적으로 처리하였다. 201 Created 요청이 처리되어서 새로운 리소스가 생성되었다. 202 Accepted 요청은 접수하였지만, 처리가 완료되지 않았다. 400 Bad Request 서버가 요청을 성공적으로 처리하였다. 401 Unauthorized 지정한 리소스에 대한 액세스 권한이 없다. 403 Forbidden 지정한 리소스에 대한 액세스가 금지되었다. 404 Not Found 지정한 리소스를 찾을 수 없다. 500 Internal Server Error 서버에 에러가 발생하였다. 501 Not Implemented 요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다. 502 Bad Gateway 웹서버가 다른 서버로부터의 잘못된 응답을 받았을 때 발생한다. 참고 : 4xx vs 5xx 4xx : 클라이언트 에러 5xx : 서버 에러 RESTful REST API의 모든 설계 규칙을 올바르게 지킨 시스템을 RESTful하다 라고 한다. REST API란 RESTful API란 REST API 제대로 알고 사용하기 http 상태코드 제대로 이해하는 REST API"
  },"/til/mongoDB.html": {
    "title": "MongoDB",
    "keywords": "til",
    "url": "/til/mongoDB.html",
    "body": "OverwriteModelError 런타임 에러 ⨯ OverwriteModelError: Cannot overwrite Users model once compiled. 해결책 ... const User = mongoose.models.Users || mongoose.model(\"Users\", userSchema); module.exports = User;"
  },"/til/jwt.html": {
    "title": "JWT 적용기",
    "keywords": "til",
    "url": "/til/jwt.html",
    "body": "사전 준비 cookie parser cors origin 설정 credentials true JWT 로직 로그인 시 인증 서버로부터 access token, refresh token을 쿠키에 넣어서 보내준다. (중요) refresh token은 httpOnly / secure / SameSite 옵션을 준다. { maxAge: 300000, // 5m httpOnly: true, secure: true, sameSite: \"strict\" } 인증 체계를 다음과 같이 만든다. 쿠키에 엑세스토큰이 있는지 확인한다. 엑세스 토큰이 없다면 엑세스토큰을 재발급 절차를 받는다. (2번으로 이동) 엑세스 토큰 있다면 엑세스토큰을 확인 절차를 밟는다. (종료) 재발급을 받는 절차에서 리프레시 토큰을 확인한다. 리프레시 토큰이 없거나 유효하지 않으면 로그인 페이지로 이동시킨다. (종료) 리프레시 토큰이 유효하다면 새로운 엑세스토큰을 발급해준다. token의 저장 위치에 관하여는 언제나 말이 많았다. 예전에 나는 localstorage에 저장해서 이번에는 cookie에 한 번 담아 본 것이다. 리액트같은 경우에 access token을 private 변수로 저장해놓고 사용해도 된다고 한다. 왜냐하면 어차피 refresh token이 있으니까 재발급받으면 된다는 의미인 것 같았다. refresh token을 일회성으로 사용하는 RTR (Refresh Token Rotation)이라는 방법도 있다. 그러고 보니 access token을 헤더에 실어 보낼 때 어떻게 했더라 싶어서 다시 찾아봤다. const accessToken = localStorage.getItem(\"accessToken\") || \"\"; const requestData = {}; axios.post(\"http://localhost:8000/like\", requestData, { headers: { Authorization: `Bearer ${accessToken}`, \"Content-Type\": \"application/json\", }, }); 아. 그리고 Bearer를 항상 붙였었는데 이건 일종의 약속이라서 그렇다고 한다. Authorization: &lt;type&gt; &lt;credentials&gt; Bearer 타입은 JWT 혹은 OAuth에 대한 토큰을 사용한다는 뜻."
  },"/til/git-github.html": {
    "title": "Git/Github",
    "keywords": "til",
    "url": "/til/git-github.html",
    "body": "git config 설정 확인 및 변경하기 git config에 대한 리스트를 보고자 하는 경우에는 아래와 같은 커맨드를 입력한다. git config --list git config 설정하는 방법 중에 가장 많이 쓰이는 것이 이름과 이메일 변경이다. 이 경우에는 아래와 같이 수정한다. git config --global user.name \"고양이\" git config --global user.email \"hbd9425@gmail.com\" 참고로 한글이 깨지는 경우에는 아래와 같이 입력한다. git config --global core.quotepath false Jekyll GitHub Pages 배포 및 테마적용 사전 준비 Ruby 설치 Jekyll 설치 테마 선택 jamstackthemes.dev http://jekyllthemes.org/ 코드블럭 선택 https://spsarolkar.github.io/rouge-theme-preview/ 배포 및 테마 적용하기 github repository 생성 repository명은 github 아이디.github.io로 생성할 것 repository는 public 으로 할 것 ex) parklego.github.io bundle 명령어 실행 bundle install bundle exec jekyll serve 블로그 설정 _conif.yml 파일에서 제목이나 이름 등을 변경 Gemfile 플러그인 설치하는 곳 siteamp 파일 생성 Gemfile 파일에서 아래 코드 추가 gem 'jekyll-sitemap' _config.yml 파일에서 아래 코드 추가 plugins: -jekyll - sitemap; Terminal 에서 bundle 입력. Terminal 에서 아래 명령어 입력 gem install jekyll-sitemap 지킬 서버 재실행 bundle exec jekyll serve commit 깔끔하게 남기기 main branch에 다른 branch를 병합할 때, 쓰이는 방법은 두 가지이다. 하나는 merge, 그리고 다른 하나는 rebase이다. 이 둘의 가장 큰 차이는 깔끔함에 있다. merge를 사용하면 모든 commit을 남기게 되지만, rebase를 사용하면 필요없는 commit을 생략시킬 수 있다. 예제를 통해 알아보기 첫 작업을 완료 후 아래와 같이 commit을 남겼다. git add . git commit -m '테스트 추가' 두 번째 작업을 완료 후 아래와 같이 commit을 남겼다. git add . git commit -m '테스트 추가 2' 세 번째 작업을 완료 후 아래와 같이 commit을 남겼다. 그리고 해당 작업이 끝나서 push를 해야하는 상황이다. git add . git commit -m '테스트 추가 3' commit을 정리하기 전에 git log를 통해 몇 개의 commit을 정리할지 파악한다. 여러 날에 걸쳐서 작업된 경우에는 몇 개의 commit을 했는지 파악하기 힘들기 때문이다. git log push 하기 전에 rebase로 불필요한 commit을 정리할 수 있다. git rebase -i @~3 // -i는 --interactive 옵션이고 대화형으로 진행한다는 뜻이다. // @~3은 root(최근)를 기준으로 3개의 commit을 rebase하겠다는 뜻이다. // HEAD~3과 같은 뜻이다. rebase 편집 화면. i를 눌러 수정모드에서 7번 과정처럼 변경한다. pick 74cd541 test 추가 pick a6d2a9f test 추가 2 pick e5e93ab test 추가 3 # Rebase 83ffc92..e5e93ab onto 83ffc92 # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 편집을 하고 :wq로 vi를 빠져나온다. pick 74cd541 test 추가 s a6d2a9f test 추가 2 // pick -&gt; s (squash) s e5e93ab test 추가 3 // pick -&gt; s (squash) # Rebase 83ffc92..e5e93ab onto 83ffc92 # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 그 다음 vi로 commit을 수정할 수 있게 된다. # This is a combination of 3 commits. # This is the 1st commit message: test 추가 # This is the commit message #2: test 추가 2 # This is the commit message #3: test 추가 3 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. ... 최종 commit 메세지를 수정하는 것이므로 그냥 다 삭제하고, commit 메세지를 작성한다. → shift + v로 블럭설정 모드로 들어간 뒤 shift + 커서로 모두 지정하고, dd를 눌러 삭제를 한다. rebase 완료 Successfully rebased and updated refs/heads/main. ssh key 생성 Git 서버들은 SSH 공개키로 인증을 한다. SSH 공개키 확인 $ cd ~/.shh $ ls id_dsa 혹은 id_dsa.pub 파일이 있으면 공개키가 생성된 적이 있는 것이다. 없다면 생성을 하자. pub확장자를 가진 파일은 공개키이므로 공개되어도 괜찮지만, 다른 파일은 개인키이므로 각별히 주의하자. SSH 공개키 생성 $ ssh-keygen 생성할 때, 묻는 질문이 있는데 그냥 엔터를 계속 눌러서 진행하자. 그러면 생성 될 것이다. 위의 커맨드를 이용해서 잘 생성되었는지 확인하고, 넘어가자. Git에 SSH key 등록 $ cat id_rsa.pub 위의 커맨드를 이용해서 값을 복사한다. 그 이후, github setting으로 들어간다. ssh and GPG keys라는 탭으로 들어가서, new ssh key 버튼을 눌러 복사한 값을 넣어주면 끝."
  },"/til/css.html": {
    "title": "CSS",
    "keywords": "til",
    "url": "/til/css.html",
    "body": "텍스트에 자연스럽게 gradient 넣기 백그라운드 영역에 먼저 그라디언트를 넣어준다. background: linear-gradient(to bottom, #194c33, #bbb); // 예시 아래와 같이 속성을 넣어준다. -webkit-background-clip: text; // 텍스트 내부에만 배경 이미지를 적용하도록 지정 -webkit-text-fill-color: transparent; // 글씨 투명하게 지정"
  }}
